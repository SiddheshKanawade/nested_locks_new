/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */
#include "annot.h"

typedef unsigned long U32;
typedef unsigned int volatile   AT91_REG;
struct motor_struct {
   int current_count ;
   int target_count ;
   int speed_percent ;
   U32 last ;
};
typedef unsigned char U8___0;
typedef signed char S8___0;
typedef unsigned short U16___0;
typedef short S16___0;
typedef unsigned long U32___0;
typedef long S32___0;
typedef char CHAR;
typedef unsigned int UINT;
typedef int SINT;
struct __anonstruct_nxt_inputs_83380041 {
   U32___0 battery_state ;
   U8___0 buttons_state ;
};
typedef struct __anonstruct_nxt_inputs_83380041 nxt_inputs;
struct __anonstruct_riff_705856829 {
   U32___0 chunkID ;
   U32___0 chunkSize ;
   U32___0 format ;
} __attribute__((__packed__)) ;
struct __anonstruct_fmt_307472724 {
   U32___0 chunkID ;
   U32___0 chunkSize ;
   U16___0 audioFormat ;
   U16___0 numChannels ;
   U32___0 sampleRate ;
   U32___0 byteRate ;
   U16___0 blockAlign ;
   U16___0 bitsPerSample ;
   U16___0 dummy ;
} __attribute__((__packed__)) ;
struct __anonstruct_data_325997328 {
   U32___0 chunkID ;
   U32___0 chunkSize ;
   U8___0 data[] ;
} __attribute__((__packed__)) ;
struct __anonstruct_WAV_1050904573 {
   struct __anonstruct_riff_705856829 riff ;
   struct __anonstruct_fmt_307472724 fmt ;
   struct __anonstruct_data_325997328 data ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_WAV_1050904573 WAV;
struct __anonstruct_riff_705856830 {
   U32___0 chunkID ;
   U32___0 chunkSize ;
   U32___0 format ;
} __attribute__((__packed__)) ;
struct __anonstruct_fmt_947264284 {
   U32___0 chunkID ;
   U32___0 chunkSize ;
   U16___0 audioFormat ;
   U16___0 numChannels ;
   U32___0 sampleRate ;
   U32___0 byteRate ;
   U16___0 blockAlign ;
   U16___0 bitsPerSample ;
} __attribute__((__packed__)) ;
struct __anonstruct_data_947264285 {
   U32___0 chunkID ;
   U32___0 chunkSize ;
   U8___0 data[] ;
} __attribute__((__packed__)) ;
struct __anonstruct_WAV_ND_214981947 {
   struct __anonstruct_riff_705856830 riff ;
   struct __anonstruct_fmt_947264284 fmt ;
   struct __anonstruct_data_947264285 data ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_WAV_ND_214981947 WAV_ND;
struct __anonstruct_riff_947264286 {
   U32___0 chunkID ;
   U32___0 chunkSize ;
   U32___0 format ;
} __attribute__((__packed__)) ;
struct __anonstruct_fmt_947264287 {
   U32___0 chunkID ;
   U32___0 chunkSize ;
   U16___0 audioFormat ;
   U16___0 numChannels ;
   U32___0 sampleRate ;
   U32___0 byteRate ;
   U16___0 blockAlign ;
   U16___0 bitsPerSample ;
   U16___0 dummy ;
} __attribute__((__packed__)) ;
struct __anonstruct_data_138372828 {
   U32___0 chunkID ;
   U32___0 chunkSize ;
   U32___0 numSamples ;
   U32___0 data_chunkID ;
   U32___0 data_chunkSize ;
   U8___0 data[] ;
} __attribute__((__packed__)) ;
struct __anonstruct_WAV_FACT_882943667 {
   struct __anonstruct_riff_947264286 riff ;
   struct __anonstruct_fmt_947264287 fmt ;
   struct __anonstruct_data_138372828 data ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_WAV_FACT_882943667 WAV_FACT;
struct __anonstruct_riff_947264288 {
   U32___0 chunkID ;
   U32___0 chunkSize ;
   U32___0 format ;
} __attribute__((__packed__)) ;
struct __anonstruct_fmt_947264289 {
   U32___0 chunkID ;
   U32___0 chunkSize ;
   U16___0 audioFormat ;
   U16___0 numChannels ;
   U32___0 sampleRate ;
   U32___0 byteRate ;
   U16___0 blockAlign ;
   U16___0 bitsPerSample ;
   U16___0 dummy ;
} __attribute__((__packed__)) ;
struct __anonstruct_data_947264290 {
   U32___0 chunkID ;
   U32___0 chunkSize ;
   U8___0 data[] ;
} __attribute__((__packed__)) ;
struct __anonstruct_WAV_NL_598610357 {
   struct __anonstruct_riff_947264288 riff ;
   struct __anonstruct_fmt_947264289 fmt ;
   struct __anonstruct_data_947264290 data ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_WAV_NL_598610357 WAV_NL;
struct __anonstruct_fileHeader_706858178 {
   U16___0 type ;
   U32___0 size ;
   U16___0 reserved1 ;
   U16___0 reserved2 ;
   U32___0 offset ;
} __attribute__((__packed__)) ;
struct __anonstruct_infoHeader_110306387 {
   U32___0 size ;
   S32___0 width ;
   S32___0 height ;
   U16___0 planes ;
   U16___0 bits ;
   U32___0 compression ;
   U32___0 imagesize ;
   S32___0 xresolution ;
   S32___0 yresolution ;
   U32___0 ncolours ;
   U32___0 importantcolours ;
} __attribute__((__packed__)) ;
struct __anonstruct_rgb_846263947 {
   U8___0 blue ;
   U8___0 green ;
   U8___0 red ;
   U8___0 reserved ;
} __attribute__((__packed__)) ;
struct __anonstruct_BMP_126705955 {
   struct __anonstruct_fileHeader_706858178 fileHeader ;
   struct __anonstruct_infoHeader_110306387 infoHeader ;
   struct __anonstruct_rgb_846263947 rgb ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_BMP_126705955 BMP;
struct __anonstruct_NXTCOLORSENSOR_T_371327434 {
   U16___0 color ;
   S16___0 rgb[3] ;
   U16___0 light ;
   U8___0 volatile   mode ;
   U8___0 volatile   mode_state ;
   U8___0 volatile   port_in_use ;
};
typedef struct __anonstruct_NXTCOLORSENSOR_T_371327434 NXTCOLORSENSOR_T;
typedef unsigned char UINT8;
typedef unsigned long UINT32;
typedef UINT8 StatusType;
typedef UINT8 TaskType;
typedef UINT8 ResourceType;
typedef UINT32 EventMaskType;
typedef UINT8 CounterType;
typedef unsigned char U8___1;
typedef short S16___1;
typedef unsigned long U32___1;
typedef long S32___1;
typedef char CHAR___0;
typedef int SINT___0;
typedef unsigned long size_t___0;
int nxt_motor_get_count(U32 n ) ;
void nxt_motor_set_count(U32 n , int count ) ;
void nxt_motor_set_speed(U32 n , int speed_percent , int brake ) ;
void nxt_motor_command(U32 n , int cmd , int target_count , int speed_percent ) ;
void nxt_motor_init(void) ;
void nxt_motor_1kHz_process(void) ;
extern void nxt_avr_set_motor(U32 n , int power_percent , int brake ) ;
extern unsigned long buttons_get(void) ;
extern unsigned long battery_voltage(void) ;
extern unsigned long sensor_adc(unsigned long n ) ;
extern void nxt_avr_set_input_power(unsigned long n , unsigned long power_type ) ;
extern void aic_set_vector(U32 vector , U32 mode , U32 isr ) ;
extern void aic_mask_on(U32 vector ) ;
extern void aic_mask_off(U32 vector ) ;
extern int interrupts_get_and_disable(void) ;
extern void interrupts_enable(void) ;
static struct motor_struct motor[3]  ;
static U32 nxt_motor_initialised  ;
static U32 interrupts_this_period  ;

extern void nxt_motor_isr_entry(void) ;

extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               unsigned long __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  unsigned long __n ) ;
extern void show_bd_addr(unsigned char *bdaddr ) ;
extern void show_bd_addr_err(void) ;
extern void add_status_info(int status ) ;
U8___0 ecrobot_get_button_state(void) ;
void ecrobot_init_nxtstate(void) ;
void ecrobot_poll_nxtstate(void) ;
void ecrobot_setDeviceInitialized(void) ;
void ecrobot_initDeviceStatus(void) ;
extern unsigned long systick_get_ms(void) ;
extern void systick_wait_ms(unsigned long ms ) ;
extern void set_digi0(int  ) ;
extern void unset_digi0(int  ) ;
extern void display_update(void) ;
extern void display_clear(unsigned long updateToo ) ;
extern void display_goto_xy(int x , int y ) ;
extern void display_string(char const   *str ) ;
extern void display_int(int val , U32___0 places ) ;
extern void display_unsigned(U32___0 val , U32___0 places ) ;
extern void i2c_disable(int port ) ;
extern void i2c_enable(int port ) ;
extern int i2c_busy(int port ) ;
extern int i2c_start_transaction(int port , U32___0 address , int internal_address ,
                                 int n_internal_address_bytes , U8___0 *data , U32___0 nbytes ,
                                 int write ) ;
extern void bt_clear_arm7_cmd(void) ;
extern void bt_set_arm7_cmd(void) ;
extern void bt_send(unsigned char *buf , unsigned long len ) ;
extern void bt_receive(unsigned char *buf ) ;
extern void bt_reset(void) ;
extern unsigned long bt_write(unsigned char *buf , unsigned long off , unsigned long len ) ;
extern unsigned long bt_read(unsigned char *buf , unsigned long off , unsigned long len ) ;
extern unsigned long bt_pending(void) ;
extern void sound_freq_vol(U32___0 freq , U32___0 ms , int vol ) ;
extern void sound_play_sample(U8___0 *data , U32___0 length , U32___0 freq , int vol ) ;
extern int sound_get_time() ;
void ecrobot_init_bt_master(unsigned char const   *bd_addr , char const   *pin ) ;
void ecrobot_init_bt_slave(char const   *pin ) ;
void ecrobot_init_bt_connection(void) ;
void ecrobot_term_bt_connection(void) ;
int ecrobot_get_bt_status(void) ;
unsigned char ecrobot_get_bt_device_address(unsigned char *bd_addr ) ;
unsigned char ecrobot_get_bt_device_name(char *bd_name ) ;
short ecrobot_get_bt_signal_strength(void) ;
unsigned char ecrobot_set_bt_device_name(char const   *bd_name ) ;
unsigned char ecrobot_set_bt_factory_settings(void) ;
unsigned long ecrobot_send_bt_packet(unsigned char *buf , unsigned long bufLen ) ;
unsigned long ecrobot_read_bt_packet(unsigned char *buf , unsigned long bufLen ) ;
unsigned long ecrobot_send_bt(void const   *buf , unsigned long off , unsigned long len ) ;
unsigned long ecrobot_read_bt(void *buf , unsigned long off , unsigned long len ) ;
S32___0 ecrobot_get_motor_rev(U8___0 port_id ) ;
void ecrobot_set_motor_speed(U8___0 port_id , S8___0 speed ) ;
void ecrobot_set_motor_mode_speed(U8___0 port_id , S32___0 mode , S8___0 speed ) ;
U16___0 ecrobot_get_light_sensor(U32___0 port_id ) ;
void ecrobot_set_light_sensor_active(U32___0 port_id ) ;
void ecrobot_set_light_sensor_inactive(U32___0 port_id ) ;
U8___0 ecrobot_get_touch_sensor(U8___0 port_id ) ;
U16___0 ecrobot_get_sound_sensor(U8___0 port_id ) ;
void ecrobot_init_i2c(U8___0 port_id , U8___0 type ) ;
U8___0 ecrobot_wait_i2c_ready(U8___0 port_id , U32___0 wait ) ;
SINT ecrobot_send_i2c(U8___0 port_id , U32___0 address , SINT i2c_reg , U8___0 *buf ,
                      U32___0 len ) ;
SINT ecrobot_read_i2c(U8___0 port_id , U32___0 address , SINT i2c_reg , U8___0 *buf ,
                      U32___0 len ) ;
void ecrobot_term_i2c(U8___0 port_id ) ;
void ecrobot_init_sonar_sensor(U8___0 port_id ) ;
long ecrobot_get_sonar_sensor(U8___0 port_id ) ;
void ecrobot_term_sonar_sensor(U8___0 port_id ) ;
void ecrobot_init_nxtcolorsensor(U8___0 port_id , U8___0 mode ) ;
void ecrobot_process_bg_nxtcolorsensor(void) ;
void ecrobot_set_nxtcolorsensor(U8___0 port_id , U8___0 mode ) ;
U8___0 ecrobot_get_nxtcolorsensor_mode(U8___0 port_id ) ;
U16___0 ecrobot_get_nxtcolorsensor_id(U8___0 port_id ) ;
void ecrobot_get_nxtcolorsensor_rgb(U8___0 port_id , S16___0 *rgb ) ;
U16___0 ecrobot_get_nxtcolorsensor_light(U8___0 port_id ) ;
void ecrobot_term_nxtcolorsensor(U8___0 port_id ) ;
void ecrobot_set_RCX_power_source(U8___0 port_id ) ;
void ecrobot_term_RCX_power_source(U8___0 port_id ) ;
S16___0 ecrobot_get_RCX_sensor(U8___0 port_id ) ;
U8___0 ecrobot_get_RCX_touch_sensor(U8___0 port_id ) ;
U16___0 ecrobot_get_battery_voltage(void) ;
U32___0 ecrobot_get_systick_ms(void) ;
U8___0 ecrobot_is_ENTER_button_pressed(void) ;
U8___0 ecrobot_is_RUN_button_pressed(void) ;
SINT ecrobot_bmp2lcd(CHAR const   *file , U8___0 *lcd , S32___0 width , S32___0 height ) ;
void ecrobot_show_int(S32___0 var ) ;
void ecrobot_debug1(UINT var1 , UINT var2 , UINT var3 ) ;
void ecrobot_debug2(UINT var1 , UINT var2 , UINT var3 ) ;
void ecrobot_status_monitor(CHAR const   *target_name ) ;
void ecrobot_adc_data_monitor(CHAR const   *target_name ) ;
void ecrobot_bt_data_logger(S8___0 data1 , S8___0 data2 ) ;
void ecrobot_bt_adc_data_logger(S8___0 data1 , S8___0 data2 , S16___0 adc1 , S16___0 adc2 ,
                                S16___0 adc3 , S16___0 adc4 ) ;
void ecrobot_sint_var_monitor(SINT *vars ) ;
int ecrobot_sound_tone(U32___0 freq , U32___0 ms , U32___0 vol ) ;
SINT ecrobot_sound_wav(CHAR const   *file , U32___0 length , S32___0 freq , U32___0 vol ) ;
void ecrobot_device_initialize(void) ;
void ecrobot_device_terminate(void) ;
void user_1ms_isr_type2(void) ;
extern void colorsensor_init(int  , unsigned char  ) ;
extern void colorsensor_term(int  ) ;
extern int colorsensor_light_get(int  ) ;
extern void colorsensor_light_full(int port ) ;
extern int colorsensor_color_get(int  ) ;
extern void colorsensor_rgb_get(int  , short * ) ;
static unsigned char volatile   deviceStatus  =    (U8___0 volatile   )2;

static S32___0 distance_state[4]  = {      (S32___0 )-1,      (S32___0 )-1,      (S32___0 )-1,      (S32___0 )-1};

static U8___0 data[4]  = {      (U8___0 )0};


U8___0 const   NXT_COLORSENSOR_PROTOCOLS[7]  = {      (U8___0 const   )176,      (U8___0 const   )112,      (U8___0 const   )240,      (U8___0 const   )8, 
        (U8___0 const   )176,      (U8___0 const   )136,      (U8___0 const   )136};
static NXTCOLORSENSOR_T sensor_data[4]  ;




static nxt_inputs ecrobot_inputs  ;
static U8___0 buttons_states[20]  ;
static SINT buttons_i  ;

extern int restart_NXT() ;

extern int shutdown_NXT() ;

extern int exec_NXT_BIOS() ;

static S16___0 adc[4]  ;



extern StatusType TerminateTask(void) ;
extern StatusType GetResource(ResourceType resid ) ;
extern StatusType ReleaseResource(ResourceType resid ) ;
extern StatusType SetEvent(TaskType tskid , EventMaskType mask ) ;
extern StatusType ClearEvent(EventMaskType mask ) ;
extern StatusType WaitEvent(EventMaskType mask ) ;
extern void ShutdownOS(StatusType ercd ) ;
extern StatusType SignalCounter(CounterType cntid ) ;
static void send_bt_command(U8___1 *cmd , U32___1 bufLen ) ;
static U32___1 read_bt_command(U8___1 *cmd , U32___1 bufLen ) ;
static U8___1 open_bt_stream(void) ;
static U8___1 close_bt_stream(void) ;
static SINT___0 connect_bt_master(U8___1 const   *bd_addr , CHAR___0 const   *pin ) ;
static SINT___0 connect_bt_slave(CHAR___0 const   *pin ) ;
static unsigned char volatile   bt_status  =    (U8___1 volatile   )4;
static U8___1 volatile   handle  ;
static U8___1 sendBuf[256]  ;
static U8___1 receiveBuf[128]  ;
extern CounterType const   SysTimerCnt ;
extern TaskType const   SpeedTask ;
extern TaskType const   BrakeTask ;
extern EventMaskType const   TouchSensorOnEvent ;
extern EventMaskType const   TouchSensorOffEvent ;
extern EventMaskType const   event1 ;
extern EventMaskType const   event2 ;
extern ResourceType const   R1 ;
int Current_speed  =    55;
int LR_Way  =    0;
int Slow_brake  =    0;
int Motor_Run  =    0;
int Pre_Order  =    0;
int Brake  ;
int Steering  ;
int Sonar_1  =    0;
int Sonar_2  =    0;
int Sonar_Check_1  =    2;
int Sonar_check_2  =    2;
int Actual_Sonar_Num_1  =    0;
int Actual_Sonar_Num_2  =    0;
int Speed_H  =    75;
int Speed_L  =    55;
int Active_Only_One_Sonar  =    0;
int Terminate_Check  =    1601;
void Motor_Run_Fun(U8___1 buf ) ;

static U8___1 bt_receive_buf[32]  ;
void TaskMainEventDispatcher(void) ;
void TaskMainEventDispatcher(void) 
{ 
  int temp ;
  float err ;
  int tmp ;
  int temp_1 ;
  U8___1 *buf6 ;
  U32___1 bufLen7 ;
  SINT___0 i8 ;
  U32___1 len9 ;

  {
  buf6 = bt_receive_buf;
  bufLen7 = (U32___1 )32;
  if ((int volatile   )bt_status == (int volatile   )7) {
    if (bufLen7 <= 126UL) {
     // bt_receive(& receiveBuf[0]);
      len9 = (U32___1 )receiveBuf[0];
      if (len9 > 0UL) {
        if (len9 <= bufLen7) {
          i8 = 0;
          while ((U32___1 )i8 < len9) {
	  ANNOT_MAXITER(4);
          //  *(buf6 + i8) = receiveBuf[i8 + 2];
            i8 ++;
          }
          goto Lret_ecrobot_read_bt_packet;
        }
      }
    }
  }
  goto Lret_ecrobot_read_bt_packet;
  Lret_ecrobot_read_bt_packet: ;
  if (Actual_Sonar_Num_1 - Actual_Sonar_Num_2 > 3) {
    bt_receive_buf[4] = (U8___1 )3;
  } else
  if (Actual_Sonar_Num_1 == 100) {
    if (Actual_Sonar_Num_2 < 50) {
      bt_receive_buf[4] = (U8___1 )3;
    } else {
      goto _L___0;
    }
  } else
  _L___0: 
  if (Actual_Sonar_Num_2 - Actual_Sonar_Num_1 > 3) {
    bt_receive_buf[4] = (U8___1 )4;
  } else
  if (Actual_Sonar_Num_2 == 100) {
    if (Actual_Sonar_Num_1 < 50) {
      bt_receive_buf[4] = (U8___1 )4;
    } else {
      goto _L;
    }
  } else
  _L: 
  if (Actual_Sonar_Num_2 < 50) {
    if (Actual_Sonar_Num_1 < 50) {
      bt_receive_buf[4] = (U8___1 )0;
    }
  }
  if (Actual_Sonar_Num_1 < 50) {
    if (Actual_Sonar_Num_2 < 50) {
      if ((Actual_Sonar_Num_1 + Actual_Sonar_Num_2) / 2 < 26) {
        if ((Actual_Sonar_Num_1 + Actual_Sonar_Num_2) / 2 > 20) {
          Current_speed = Speed_L;
          Motor_Run = 1;
          bt_receive_buf[3] = (U8___1 )1;
        } else {
          goto _L___1;
        }
      } else
      _L___1: 
      if ((Actual_Sonar_Num_1 + Actual_Sonar_Num_2) / 2 >= 26) {
        Current_speed = Speed_H;
        Motor_Run = 1;
        bt_receive_buf[3] = (U8___1 )1;
      } else {
        Current_speed = 0;
        Motor_Run = 0;
        //nxt_motor_set_speed((U32___1 )1, 0, 1);
        //nxt_motor_set_speed((U32___1 )2, 0, 1);
        bt_receive_buf[3] = (U8___1 )0;
      }
      Terminate_Check = 0;
    } else {
      goto _L___2;
    }
  } else
  _L___2: 
  if (Actual_Sonar_Num_1 < 50) {
    Current_speed = Speed_L;
    Motor_Run = 1;
    bt_receive_buf[3] = (U8___1 )1;
    Terminate_Check = 0;
  } else
  if (Actual_Sonar_Num_2 < 50) {
    Current_speed = Speed_L;
    Motor_Run = 1;
    bt_receive_buf[3] = (U8___1 )1;
    Terminate_Check = 0;
  } else {
    Terminate_Check ++;
    if (Terminate_Check == 700) {
      Current_speed = 0;
      Motor_Run = 0;
      //nxt_motor_set_speed((U32___1 )1, 0, 1);
      //nxt_motor_set_speed((U32___1 )2, 0, 1);
      bt_receive_buf[3] = (U8___1 )0;
      //ecrobot_sound_tone((U32___1 )1500, (U32___1 )80, (U32___1 )80);
    }
  }
  temp = Pre_Order;
  if ((int )bt_receive_buf[3] == 1) {
    temp = (int )bt_receive_buf[3];
  } else
  if ((int )bt_receive_buf[3] == 2) {
    temp = (int )bt_receive_buf[3];
  }
  if (temp != Pre_Order) {
    if ((int )bt_receive_buf[4] != 3) {
      if ((int )bt_receive_buf[4] != 4) {
        if (LR_Way != 100) {
          if (LR_Way != -100) {
            Motor_Run = 1;
          }
        }
      }
    }
  }
  if ((int )bt_receive_buf[4] == 3) {
    LR_Way = -100;
  } else
  if ((int )bt_receive_buf[4] == 4) {
    LR_Way = 100;
  } else {
    LR_Way = 0;
  }
  tmp = 1;//nxt_motor_get_count((U32___1 )0);
  //err = (float )((50 * LR_Way) / 100 - tmp);
  if (err > (float )0) {
    //nxt_motor_set_speed((U32___1 )0, (int )(err / (float )2 + (float )10), 1);
  } else
  if (err < (float )0) {
    //nxt_motor_set_speed((U32___1 )0, (int )(err / (float )2 - (float )10), 1);
  } else {
    //nxt_motor_set_speed((U32___1 )0, 0, 1);
  }
  if ((int )bt_receive_buf[5] == 1) {
    if (Current_speed != Speed_H) {
      Motor_Run = 1;
      //SetEvent((TaskType )SpeedTask, (EventMaskType )event1);
    }
  } else
  if ((int )bt_receive_buf[5] == 2) {
    if (Current_speed != Speed_L) {
      Motor_Run = 1;
      //SetEvent((TaskType )SpeedTask, (EventMaskType )event1);
    }
  }
  if (Slow_brake > 0) {
    if (Current_speed == Speed_H) {
      temp_1 = ((Speed_H * 2 + 1) - Slow_brake) / 2;
    }
    if (Current_speed == Speed_L) {
      temp_1 = ((Speed_L * 2 + 1) - Slow_brake) / 2;
    }
    if ((int )bt_receive_buf[3] == 1) {
      //nxt_motor_set_speed((U32___1 )1, - Current_speed + temp_1, 1);
      //nxt_motor_set_speed((U32___1 )2, - Current_speed + temp_1, 1);
    }
    if ((int )bt_receive_buf[3] == 2) {
      //nxt_motor_set_speed((U32___1 )1, Current_speed - temp_1, 1);
      //nxt_motor_set_speed((U32___1 )2, Current_speed - temp_1, 1);
    }
    Slow_brake --;
    Motor_Run = 0;
  } else
  if ((int )bt_receive_buf[6] == 1) {
    goto _L___4;
  } else
  if ((int )bt_receive_buf[6] == 2) {
    _L___4: 
    if ((int )bt_receive_buf[7] == 1) {
      Brake = (int )bt_receive_buf[6];
      //SetEvent((TaskType )BrakeTask, (EventMaskType )event2);
    } else {
      goto _L___3;
    }
  } else
  _L___3: 
  if (Motor_Run == 1) {
    //Motor_Run_Fun(bt_receive_buf[3]);
    if ((int )bt_receive_buf[3] == 1) {
      Pre_Order = (int )bt_receive_buf[3];
    } else
    if ((int )bt_receive_buf[3] == 2) {
      Pre_Order = (int )bt_receive_buf[3];
    }
  }
  //TerminateTask();
  return;
}
}
static U8___1 bt_send_buf[32]  ;
void TaskMainEventHandler(void) 
{ 

   int i = 0;
  {
  while (i<1) {
  ANNOT_MAXITER(1);
     bt_send_buf[0] = (U8___1 )1;
    bt_send_buf[0] = (U8___1 )0;
    //ecrobot_send_bt_packet(bt_send_buf, (U32___1 )32);
    i++;
  }
  //TerminateTask();
}
}
void TaskMainInitialize(void) 
{ 
  int Count_temp ;
  int Right_Count ;
  int Left_Count ;
  int temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  //GetResource((ResourceType )R1);
  Count_temp = 0;
  Right_Count = 0;
  Left_Count = 0;
  temp = 100;
  //nxt_motor_set_speed((U32___1 )0, 35, 1);
  int i=0;
  while (i<1) {
    ANNOT_MAXITER(1);
    tmp = 1;//nxt_motor_get_count((U32___1 )0);
    if (! (temp != tmp)) {
      break;
    }
    temp = 1;//nxt_motor_get_count((U32___1 )0);
   // systick_wait_ms((U32___1 )50);
  }
  //nxt_motor_set_speed((U32___1 )0, 0, 1);
  Right_Count = 1;//nxt_motor_get_count((U32___1 )0);
  //nxt_motor_set_speed((U32___1 )0, -35, 1);
  temp = 100;
  while (i<1) {
    ANNOT_MAXITER(1);
    tmp___0 = 1;//nxt_motor_get_count((U32___1 )0);
    if (! (temp != tmp___0)) {
      break;
    }
    temp = 1;//nxt_motor_get_count((U32___1 )0);
    //systick_wait_ms((U32___1 )50);
  }
  //nxt_motor_set_speed((U32___1 )0, 0, 1);
  Left_Count = 1;//nxt_motor_get_count((U32___1 )0);
  Count_temp = (Right_Count - Left_Count) / 2 + Left_Count;
  //nxt_motor_set_speed((U32___1 )0, 35, 1);
  temp = 1;//nxt_motor_get_count((U32___1 )0);
  while (temp != Count_temp) {
    ANNOT_MAXITER(3);
    temp = 1;//nxt_motor_get_count((U32___1 )0);
  }
  
  tmp___1 = 1;//nxt_motor_get_count((U32___1 )1);
  Right_Count = tmp___1 / 10;
  tmp___2 = 1;//nxt_motor_get_count((U32___1 )2);
  Left_Count = tmp___2 / 10;
  Steering = 38 + ((Right_Count + Left_Count) / 2) * 2;
  //ReleaseResource((ResourceType )R1);
  //TerminateTask();
  return;
}
}
void TaskMainSpeedTask(void) 
{ 

  int i = 0;
  {
  while (i<1) {
    ANNOT_MAXITER(1);
   // GetResource((ResourceType )R1);
    if (Current_speed == Speed_L) {
      Current_speed = Speed_H;
    } else
    if (Current_speed == Speed_H) {
      Current_speed = Speed_L;
    }
    
    //ReleaseResource((ResourceType )R1);
  }
 // TerminateTask();
}
}
void TaskMainBrakeTask(void) 
{ 

  int i = 0;
  {
  while (i<1) {
    ANNOT_MAXITER(1);
    //GetResource((ResourceType )R1);
    if (Brake == 1) {
     // nxt_motor_set_speed((U32___1 )1, 0, 1);
     // nxt_motor_set_speed((U32___1 )2, 0, 1);
    } else
    if (Brake == 2) {
      if (Current_speed == Speed_H) {
        if (Motor_Run == 1) {
          Slow_brake = Speed_H * 2;
        } else {
          goto _L;
        }
      } else
      _L: 
      if (Current_speed == Speed_L) {
        if (Motor_Run == 1) {
          Slow_brake = Speed_L * 2;
        }
      }
      Motor_Run = 0;
    }
    //ReleaseResource((ResourceType )R1);
  }
 // TerminateTask();
}
}
void TaskMainSonarSensing(void) 
{ 
  int temp ;
  S32___1 tmp ;
  int temp1 ;
  S32___1 tmp___0 ;
  U8___0 port_id5 ;
  int tmp6 ;
  long ret_ecrobot_get_sonar_sensor7 ;
  U8___0 port_id8 ;
  int tmp9 ;
  long ret_ecrobot_get_sonar_sensor10 ;

  {
  if (Active_Only_One_Sonar == 0) {
    temp = 0;
    port_id5 = (U8___1 )1;
    tmp6 = 1;//i2c_busy((int )port_id5);
    if (tmp6 == 0) {
      distance_state[port_id5] = (S32___0 )data[port_id5];
      //i2c_start_transaction((int )port_id5, (U32___0 )1, 66, 1, & data[port_id5],                          (U32___0 )1, 0);
    }
    ret_ecrobot_get_sonar_sensor7 = distance_state[port_id5];
    goto Lret_ecrobot_get_sonar_sensor;
    Lret_ecrobot_get_sonar_sensor: 
    tmp = ret_ecrobot_get_sonar_sensor7;
    temp = (int )tmp;
    if (temp < 50) {
      if (temp > 1) {
        if (Sonar_1 == temp) {
          if (temp != 0) {
            Sonar_Check_1 --;
            if (Sonar_Check_1 == 0) {
              Actual_Sonar_Num_1 = temp;
              Sonar_Check_1 = 1;
            }
          } else {
            Sonar_1 = temp;
            Sonar_Check_1 = 2;
          }
        } else {
          Sonar_1 = temp;
          Sonar_Check_1 = 2;
        }
      } else {
        Actual_Sonar_Num_1 = 100;
      }
    } else {
      Actual_Sonar_Num_1 = 100;
    }
  } else
  if (Active_Only_One_Sonar == 1) {
    temp1 = 0;
    port_id8 = (U8___1 )2;
    tmp9 = 1;//i2c_busy((int )port_id8);
    if (tmp9 == 0) {
      distance_state[port_id8] = (S32___0 )data[port_id8];
      //i2c_start_transaction((int )port_id8, (U32___0 )1, 66, 1, & data[port_id8],           (U32___0 )1, 0);
    }
    ret_ecrobot_get_sonar_sensor10 = distance_state[port_id8];
    goto Lret_ecrobot_get_sonar_sensor___0;
    Lret_ecrobot_get_sonar_sensor___0: 
    tmp___0 = ret_ecrobot_get_sonar_sensor10;
    temp1 = (int )tmp___0;
    if (temp1 < 50) {
      if (temp1 > 1) {
        if (Sonar_2 == temp1) {
          if (temp1 != 0) {
            Sonar_check_2 --;
            if (Sonar_check_2 == 0) {
              Actual_Sonar_Num_2 = temp1;
              Sonar_check_2 = 1;
            }
          } else {
            Sonar_2 = temp1;
            Sonar_check_2 = 2;
          }
        } else {
          Sonar_2 = temp1;
          Sonar_check_2 = 2;
        }
      } else {
        Actual_Sonar_Num_2 = 100;
      }
    } else {
      Actual_Sonar_Num_2 = 100;
    }
  }
  if (Active_Only_One_Sonar == 0) {
    Active_Only_One_Sonar = 1;
  } else
  if (Active_Only_One_Sonar == 1) {
    Active_Only_One_Sonar = 0;
  }
 // TerminateTask();
  return;
}
}
void TaskMainIdleTask(void) ;
static SINT___0 bt_status___0  =    4;
void TaskMainIdleTask(void) 
{ 
  SINT___0 tmp ;
  char const   *pin2 ;
  int i = 0;
  {
  while (i<1) {
    ANNOT_MAXITER(1);
    {
    pin2 = "LEJOS-DONGHYUN";
    {
    
    goto Lret_ecrobot_init_bt_slave;
    }
    Lret_ecrobot_init_bt_slave: /* CIL Label */ ;
    tmp = 1;//ecrobot_get_bt_status();
    }
    if (tmp == 7) {
      if (bt_status___0 != 7) {
        //display_clear((U32___1 )0);
        
      }
    }
    bt_status___0 = 1;//ecrobot_get_bt_status();
  }
}
}
void TaskMainInitialize_blk() 
{ 
  int Count_temp ;
  int Right_Count ;
  int Left_Count ;
  int temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  //GetResource((ResourceType )R1);
  Count_temp = 0;
  Right_Count = 0;
  Left_Count = 0;
  temp = 100;
  //nxt_motor_set_speed((U32___1 )0, 35, 1);
  int i=0;
  while (i<1) {
    ANNOT_MAXITER(1);
    tmp = 1;//nxt_motor_get_count((U32___1 )0);
    if (! (temp != tmp)) {
      break;
    }
    temp = 1;//nxt_motor_get_count((U32___1 )0);
   // systick_wait_ms((U32___1 )50);
  }
  //nxt_motor_set_speed((U32___1 )0, 0, 1);
  Right_Count = 1;//nxt_motor_get_count((U32___1 )0);
  //nxt_motor_set_speed((U32___1 )0, -35, 1);
  temp = 100;
  while (i<1) {
    ANNOT_MAXITER(1);
    tmp___0 = 1;//nxt_motor_get_count((U32___1 )0);
    if (! (temp != tmp___0)) {
      break;
    }
    temp = 1;//nxt_motor_get_count((U32___1 )0);
    //systick_wait_ms((U32___1 )50);
  }
  //nxt_motor_set_speed((U32___1 )0, 0, 1);
  Left_Count = 1;//nxt_motor_get_count((U32___1 )0);
  Count_temp = (Right_Count - Left_Count) / 2 + Left_Count;
  //nxt_motor_set_speed((U32___1 )0, 35, 1);
  temp = 1;//nxt_motor_get_count((U32___1 )0);
  while (temp != Count_temp) {
    ANNOT_MAXITER(3);
    temp = 1;//nxt_motor_get_count((U32___1 )0);
  }
  
  tmp___1 = 1;//nxt_motor_get_count((U32___1 )1);
  Right_Count = tmp___1 / 10;
  tmp___2 = 1;//nxt_motor_get_count((U32___1 )2);
  Left_Count = tmp___2 / 10;
  Steering = 38 + ((Right_Count + Left_Count) / 2) * 2;
  //ReleaseResource((ResourceType )R1);
  //TerminateTask();
  
}
}

void TaskMainSpeedTask_blk() 
{ 
   // GetResource((ResourceType )R1);
    if (Current_speed == Speed_L) {
      Current_speed = Speed_H;
    } else
    if (Current_speed == Speed_H) {
      Current_speed = Speed_L;
    }
    
    //ReleaseResource((ResourceType )R1);
  
}

void TaskMainBrakeTask_blk() 
{ 

  
    //GetResource((ResourceType )R1);
    if (Brake == 1) {
     // nxt_motor_set_speed((U32___1 )1, 0, 1);
     // nxt_motor_set_speed((U32___1 )2, 0, 1);
    } else
    if (Brake == 2) {
      if (Current_speed == Speed_H) {
        if (Motor_Run == 1) {
          Slow_brake = Speed_H * 2;
        } else {
          goto _L;
        }
      } else
      _L: 
      if (Current_speed == Speed_L) {
        if (Motor_Run == 1) {
          Slow_brake = Speed_L * 2;
        }
      }
      Motor_Run = 0;
    }
    //ReleaseResource((ResourceType )R1);
 
}

extern int create_task() ;
void main(void) 
{ 


  {

 // TaskMainSonarSensing();
 //TaskMainEventDispatcher();
 //TaskMainInitialize();
 //TaskMainSpeedTask();
 //TaskMainBrakeTask();
 //TaskMainEventHandler();
 //TaskMainIdleTask();
 //TaskMainInitialize_blk();
 //TaskMainSpeedTask_blk();
 TaskMainBrakeTask_blk();
  return;
}
}
