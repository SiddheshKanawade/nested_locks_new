/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 3 "nxtgt/nxtgt.c"
typedef unsigned char U8;
#line 4 "nxtgt/nxtgt.c"
typedef signed char S8;
#line 7 "nxtgt/nxtgt.c"
typedef unsigned long U32;
#line 8 "nxtgt/nxtgt.c"
typedef long S32;
#line 9 "nxtgt/nxtgt.c"
typedef char CHAR;
#line 11 "nxtgt/nxtgt.c"
typedef int SINT;
#line 12 "nxtgt/nxtgt.c"
struct __anonstruct_nxt_inputs_83380041 {
   U32 battery_state ;
   U8 buttons_state ;
};
#line 16 "nxtgt/nxtgt.c"
typedef struct __anonstruct_nxt_inputs_83380041 nxt_inputs;
#line 168 "nxtgt/nxtgt.c"
typedef unsigned char UINT8;
#line 169 "nxtgt/nxtgt.c"
typedef UINT8 StatusType;
#line 170 "nxtgt/nxtgt.c"
typedef unsigned char U8___0;
#line 171 "nxtgt/nxtgt.c"
typedef signed char S8___0;
#line 173 "nxtgt/nxtgt.c"
typedef unsigned long U32___0;
#line 174 "nxtgt/nxtgt.c"
typedef long S32___0;
#line 176 "nxtgt/nxtgt.c"
typedef int SINT___0;
#line 192
extern unsigned long systick_get_ms(void) ;
#line 196
extern U32 sensor_adc(U32 n ) ;
#line 198
extern int nxt_motor_get_count(unsigned long n ) ;
#line 199
extern void nxt_motor_set_count(unsigned long n , int count ) ;
#line 200
extern void nxt_motor_set_speed(unsigned long n , int speed_percent , int brake ) ;
#line 203
extern void display_update(void) ;
#line 204
extern void display_clear(U32 updateToo ) ;
#line 205
extern void display_goto_xy(int x , int y ) ;
#line 206
extern void display_string(char const   *str ) ;
#line 207
extern void display_int(int val , U32 places ) ;
#line 208
extern void display_unsigned(U32 val , U32 places ) ;
#line 217
extern void bt_receive(unsigned char *buf ) ;
#line 229
extern int ecrobot_get_bt_status(void) ;
#line 253
extern long ecrobot_get_sonar_sensor(U8 port_id ) ;
#line 277
extern void ecrobot_bt_data_logger(S8 data1 , S8 data2 ) ;
#line 292 "nxtgt/nxtgt.c"
U8 const   NXT_COLORSENSOR_PROTOCOLS[7]  = {      (U8 const   )176,      (U8 const   )112,      (U8 const   )240,      (U8 const   )8, 
        (U8 const   )176,      (U8 const   )136,      (U8 const   )136};
#line 296 "nxtgt/nxtgt.c"
static nxt_inputs ecrobot_inputs  ;
#line 302
extern StatusType TerminateTask(void) ;
#line 309 "nxtgt/nxtgt.c"
static unsigned char volatile   bt_status  =    (U8___0 volatile   )4;
#line 312 "nxtgt/nxtgt.c"
static U8___0 receiveBuf[128]  ;
#line 313 "nxtgt/nxtgt.c"
static S8___0 EDC_flag  ;
#line 314
S32___0 FrictionComp(S32___0 ratio , S32___0 offset ) ;
#line 315 "nxtgt/nxtgt.c"
void TaskMainTaskInitialize(void) 
{ 


  {
#line 317
  nxt_motor_set_speed((U32___0 )0, 0, 1);
#line 318
  nxt_motor_set_speed((U32___0 )2, 0, 1);
#line 319
  nxt_motor_set_speed((U32___0 )1, 0, 1);
#line 320
  nxt_motor_set_count((U32___0 )0, 0);
#line 321
  nxt_motor_set_count((U32___0 )2, 0);
#line 322
  nxt_motor_set_count((U32___0 )1, 0);
#line 323
  EDC_flag = (S8___0 )1;
#line 324
  TerminateTask();
#line 325
  return;
}
}
#line 327
void TaskMainTaskControl(void) ;
#line 328 "nxtgt/nxtgt.c"
static U8___0 touch_sensor_state  =    (U8___0 )0;
#line 329 "nxtgt/nxtgt.c"
static U8___0 bt_receive_buf[32]  ;
#line 330 "nxtgt/nxtgt.c"
void TaskMainTaskControl(void) 
{ 
  S32___0 analog_stick_left ;
  S32___0 analog_stick_right ;
  S32___0 steering_angle ;
  S32___0 steering_err ;
  S32___0 steering_speed ;
  S32___0 diff_gain ;
  U8___0 touch_sensor ;
  int tmp ;
  S32___0 tmp___0 ;
  S32___0 tmp___1 ;
  S32___0 tmp___2 ;
  S32___0 tmp___3 ;
  S32___0 tmp___4 ;
  S32___0 tmp___5 ;
  S32___0 tmp___6 ;
  U8___0 *buf16 ;
  U32___0 bufLen17 ;
  SINT___0 i18 ;
  U32___0 len19 ;
  U8 port_id20 ;
  U32 tmp21 ;
  unsigned char ret_ecrobot_get_touch_sensor22 ;

  {
#line 355
  buf16 = bt_receive_buf;
#line 356
  bufLen17 = (U32___0 )32;
#line 357
  if ((int volatile   )bt_status == (int volatile   )7) {
#line 358
    if (bufLen17 <= 126UL) {
#line 359
      bt_receive(& receiveBuf[0]);
#line 360
      len19 = (U32___0 )receiveBuf[0];
#line 361
      if (len19 > 0UL) {
#line 362
        if (len19 <= bufLen17) {
#line 363
          i18 = 0;
#line 364
          while ((U32___0 )i18 < len19) {
#line 365
            *(buf16 + i18) = receiveBuf[i18 + 2];
#line 366
            i18 ++;
          }
#line 368
          goto Lret_ecrobot_read_bt_packet;
        }
      }
    }
  }
#line 373
  goto Lret_ecrobot_read_bt_packet;
  Lret_ecrobot_read_bt_packet: 
#line 375
  analog_stick_left = - ((S32___0 )*((S8___0 *)(& bt_receive_buf[0])));
#line 376
  analog_stick_right = (S32___0 )*((S8___0 *)(& bt_receive_buf[1]));
#line 377
  port_id20 = (U8___0 )3;
#line 378
  tmp21 = sensor_adc((U32 )port_id20);
#line 379
  ret_ecrobot_get_touch_sensor22 = (U8 )(tmp21 < 512UL);
#line 380
  goto Lret_ecrobot_get_touch_sensor;
  Lret_ecrobot_get_touch_sensor: 
#line 382
  touch_sensor = ret_ecrobot_get_touch_sensor22;
#line 383
  if ((int )touch_sensor == 1) {
#line 384
    if ((int )touch_sensor_state == 0) {
#line 385
      EDC_flag = (S8___0 )(~ ((int )EDC_flag) + 1);
    }
  }
#line 388
  touch_sensor_state = touch_sensor;
#line 389
  tmp = nxt_motor_get_count((U32___0 )0);
#line 390
  steering_angle = (S32___0 )tmp;
#line 391
  steering_err = (40L * analog_stick_right) / 100L - steering_angle;
#line 392
  steering_speed = 2L * steering_err;
#line 393
  tmp___0 = FrictionComp(steering_speed, (S32___0 )10);
#line 394
  nxt_motor_set_speed((U32___0 )0, (int )tmp___0, 1);
#line 395
  diff_gain = (S32___0 )10;
#line 396
  if (steering_angle > 2L) {
#line 397
    if ((int )EDC_flag == -1) {
#line 398
      diff_gain = (S32___0 )((1.0F - ((float )steering_angle * 0.7F) / (float )40) * (float )10);
    }
#line 400
    tmp___1 = FrictionComp((analog_stick_left * diff_gain) / 10L, (S32___0 )10);
#line 401
    nxt_motor_set_speed((U32___0 )2, (int )tmp___1, 1);
#line 402
    tmp___2 = FrictionComp(analog_stick_left, (S32___0 )10);
#line 403
    nxt_motor_set_speed((U32___0 )1, (int )tmp___2, 1);
  } else
#line 405
  if (steering_angle < -2L) {
#line 406
    if ((int )EDC_flag == -1) {
#line 407
      diff_gain = (S32___0 )((1.0F + ((float )steering_angle * 0.7F) / (float )40) * (float )10);
    }
#line 409
    tmp___3 = FrictionComp(analog_stick_left, (S32___0 )10);
#line 410
    nxt_motor_set_speed((U32___0 )2, (int )tmp___3, 1);
#line 411
    tmp___4 = FrictionComp((analog_stick_left * diff_gain) / 10L, (S32___0 )10);
#line 412
    nxt_motor_set_speed((U32___0 )1, (int )tmp___4, 1);
  } else {
#line 414
    tmp___5 = FrictionComp(analog_stick_left, (S32___0 )10);
#line 415
    nxt_motor_set_speed((U32___0 )2, (int )tmp___5, 1);
#line 416
    tmp___6 = FrictionComp(analog_stick_left, (S32___0 )10);
#line 417
    nxt_motor_set_speed((U32___0 )1, (int )tmp___6, 1);
  }
#line 419
  ecrobot_bt_data_logger((S8___0 )analog_stick_left, (S8___0 )analog_stick_right);
#line 420
  TerminateTask();
#line 421
  return;
}
}
#line 424 "nxtgt/nxtgt.c"
void TaskMainTaskSonar(void) 
{ 
  S32___0 sonar ;

  {
#line 429
  sonar = ecrobot_get_sonar_sensor((U8___0 )1);
#line 430
  TerminateTask();
#line 431
  return;
}
}
#line 491
extern int ( /* missing proto */  getDistance)() ;
#line 434 "nxtgt/nxtgt.c"
void TaskMainTaskLCD(void) 
{ 
  CHAR const   *target_name1 ;
  U32 tmp2 ;
  int tmp___03 ;
  int tmp___14 ;
  int tmp___25 ;
  U32 tmp___36 ;
  U32 tmp___47 ;
  U32 tmp___58 ;
  U32 tmp___69 ;
  SINT tmp___710 ;
  S32 tmp___811 ;
  int tmp ;

  {
#line 449
  target_name1 = "NXT GT";
#line 451
  display_clear((U32 )0);
#line 452
  display_goto_xy(0, 0);
#line 453
  display_string(target_name1);
#line 454
  display_goto_xy(0, 1);
#line 455
  display_string("TIME:");
#line 456
  tmp2 = systick_get_ms();
#line 457
  display_unsigned(tmp2 / 1000UL, (U32 )0);
#line 458
  display_goto_xy(0, 2);
#line 459
  display_string("BATT:");
#line 460
  display_unsigned(ecrobot_inputs.battery_state / 100UL, (U32 )0);
#line 461
  display_goto_xy(0, 3);
#line 462
  display_string("REV: ");
#line 463
  tmp___03 = nxt_motor_get_count((U32 )0);
#line 464
  display_int(tmp___03, (U32 )0);
#line 465
  tmp___14 = nxt_motor_get_count((U32 )1);
#line 466
  display_int(tmp___14, (U32 )6);
#line 467
  display_goto_xy(0, 4);
#line 468
  display_string("     ");
#line 469
  tmp___25 = nxt_motor_get_count((U32 )2);
#line 470
  display_int(tmp___25, (U32 )0);
#line 471
  display_goto_xy(0, 5);
#line 472
  display_string("ADC: ");
#line 473
  tmp___36 = sensor_adc((U32 )0);
#line 474
  display_unsigned(tmp___36, (U32 )0);
#line 475
  tmp___47 = sensor_adc((U32 )1);
#line 476
  display_unsigned(tmp___47, (U32 )5);
#line 477
  display_goto_xy(0, 6);
#line 478
  display_string("     ");
#line 479
  tmp___58 = sensor_adc((U32 )2);
#line 480
  display_unsigned(tmp___58, (U32 )0);
#line 481
  tmp___69 = sensor_adc((U32 )3);
#line 482
  display_unsigned(tmp___69, (U32 )5);
#line 483
  display_goto_xy(0, 7);
#line 484
  display_string("BT/DST: ");
#line 485
  tmp___710 = ecrobot_get_bt_status();
#line 486
  if (tmp___710 == 7) {
#line 487
    display_unsigned((U32 )1, (U32 )0);
  } else {
#line 489
    display_unsigned((U32 )0, (U32 )0);
  }
#line 491
  tmp = getDistance();
#line 491
  tmp___811 = (S32 )tmp;
#line 492
  display_int((int )tmp___811, (U32 )5);
#line 493
  display_update();
#line 494
  goto Lret_ecrobot_status_monitor;
  Lret_ecrobot_status_monitor: 
#line 497
  TerminateTask();
#line 499
  return;
}
}
#line 502 "nxtgt/nxtgt.c"
S32___0 FrictionComp(S32___0 ratio , S32___0 offset ) 
{ 


  {
#line 505
  if (ratio > 0L) {
#line 506
    return (((100L - offset) * ratio) / 100L + offset);
  } else
#line 508
  if (ratio < 0L) {
#line 509
    return (((100L - offset) * ratio) / 100L - offset);
  } else {
#line 511
    return (ratio);
  }
}
}
#line 515
extern int create_task() ;
#line 516 "nxtgt/nxtgt.c"
void main(void) 
{ 


  {
#line 519
  create_task("TaskMainTaskInitialize", "TaskMainTaskInitialize", 4, 800, 0.009);
#line 520
  create_task("TaskMainTaskControl", "TaskMainTaskControl", 3, 10, 0.082);
#line 521
  create_task("TaskMainTaskSonar", "TaskMainTaskSonar", 2, 50, 0.009);
#line 522
  create_task("TaskMainTaskLCD", "TaskMainTaskLCD", 1, 500, 0.020);
#line 523
  return;
}
}
