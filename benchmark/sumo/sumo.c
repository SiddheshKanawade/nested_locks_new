/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */
typedef unsigned char U8;
typedef unsigned long U32;
typedef unsigned char byte;
typedef unsigned short TWOBYTES;
typedef unsigned long FOURBYTES;
typedef FOURBYTES STACKWORD;
struct _freeBlock {
   TWOBYTES size : 15 ;
   TWOBYTES isAllocated : 1 ;
} __attribute__((__packed__)) ;
struct _objects {
   byte _class ;
   byte padding : 5 ;
   byte mark : 1 ;
   byte isArray : 1 ;
   byte isAllocated : 1 ;
} __attribute__((__packed__)) ;
struct _arrays {
   TWOBYTES length : 9 ;
   TWOBYTES type : 4 ;
   TWOBYTES mark : 1 ;
   TWOBYTES isArray : 1 ;
   TWOBYTES isAllocated : 1 ;
} __attribute__((__packed__)) ;
union _flags {
   TWOBYTES all ;
   struct _freeBlock freeBlock ;
   struct _objects objects ;
   struct _arrays arrays ;
} __attribute__((__packed__)) ;
struct S_Object {
   union _flags flags ;
   byte monitorCount ;
   byte threadId ;
} __attribute__((__packed__)) ;
typedef struct S_Object Object;
typedef unsigned int volatile   AT91_REG;
typedef unsigned long size_t;
struct __anonstruct_display_array_740464799 {
   Object hdr ;
   U8 displayN[9][100] ;
} __attribute__((__packed__)) ;
typedef unsigned char U8___0;
typedef unsigned short U16___0;
typedef unsigned long U32___0;
typedef unsigned int AT91_REG___0;
struct i2c_pin_pair {
   U32___0 scl ;
   U32___0 sda ;
};
struct i2c_partial_transaction {
   U8___0 start : 1 ;
   U8___0 restart : 1 ;
   U8___0 stop : 1 ;
   U8___0 tx : 1 ;
   U8___0 last_pt : 1 ;
   U16___0 nbytes ;
   U8___0 *data ;
};
enum __anonenum_i2c_port_state_506411302 {
    I2C_UNINITIALISED = 0,
    I2C_IDLE = 1,
    I2C_BEGIN = 2,
    I2C_RESTART1 = 3,
    I2C_START1 = 4,
    I2C_START2 = 5,
    I2C_START3 = 6,
    I2C_START_RECLOCK1 = 7,
    I2C_LOW0 = 8,
    I2C_LOW1 = 9,
    I2C_HIGH0 = 10,
    I2C_HIGH1 = 11,
    I2C_STOP0 = 12,
    I2C_STOP1 = 13,
    I2C_STOP2 = 14,
    I2C_STOP3 = 15
} ;
typedef enum __anonenum_i2c_port_state_506411302 i2c_port_state;
struct i2c_port_struct {
   U32___0 scl_pin ;
   U32___0 sda_pin ;
   U8___0 addr_int[2] ;
   U8___0 addr ;
   struct i2c_partial_transaction partial_transaction[3] ;
   struct i2c_partial_transaction *current_pt ;
   i2c_port_state state ;
   U32___0 nbits ;
   U32___0 ack_slot ;
   U32___0 ack_slot_pending ;
   U8___0 *dataN ; //check data -> dataN
   U32___0 transmitting ;
   U32___0 fault ;
   U32___0 n_fault ;
   U32___0 n_good ;
   U32___0 ack_fail ;
   U32___0 ack_good ;
   U32___0 pt_num ;
   U32___0 pt_begun ;
};
typedef unsigned char U8___1;
typedef signed char S8___0;
typedef unsigned short U16___1;
typedef short S16___0;
typedef unsigned long U32___1;
typedef long S32___0;
typedef char CHAR;
typedef unsigned int UINT;
typedef int SINT;
struct __anonstruct_nxt_inputs_83380041 {
   U32___1 battery_state ;
   U8___1 buttons_state ;
};
typedef struct __anonstruct_nxt_inputs_83380041 nxt_inputs;
struct __anonstruct_riff_705856829 {
   U32___1 chunkID ;
   U32___1 chunkSize ;
   U32___1 format ;
} __attribute__((__packed__)) ;
struct __anonstruct_fmt_307472724 {
   U32___1 chunkID ;
   U32___1 chunkSize ;
   U16___1 audioFormat ;
   U16___1 numChannels ;
   U32___1 sampleRate ;
   U32___1 byteRate ;
   U16___1 blockAlign ;
   U16___1 bitsPerSample ;
   U16___1 dummy ;
} __attribute__((__packed__)) ;
struct __anonstruct_data_325997328 {
   U32___1 chunkID ;
   U32___1 chunkSize ;
   U8___1 data[] ; 
} __attribute__((__packed__)) ;
struct __anonstruct_WAV_365060792 {
   struct __anonstruct_riff_705856829 riff ;
   struct __anonstruct_fmt_307472724 fmt ;
   struct __anonstruct_data_325997328 data ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_WAV_365060792 WAV;
struct __anonstruct_riff_717123104 {
   U32___1 chunkID ;
   U32___1 chunkSize ;
   U32___1 format ;
} __attribute__((__packed__)) ;
struct __anonstruct_fmt_947264284 {
   U32___1 chunkID ;
   U32___1 chunkSize ;
   U16___1 audioFormat ;
   U16___1 numChannels ;
   U32___1 sampleRate ;
   U32___1 byteRate ;
   U16___1 blockAlign ;
   U16___1 bitsPerSample ;
} __attribute__((__packed__)) ;
struct __anonstruct_data_947264285 {
   U32___1 chunkID ;
   U32___1 chunkSize ;
   U8___1 data[] ;
} __attribute__((__packed__)) ;
struct __anonstruct_WAV_ND_717123103 {
   struct __anonstruct_riff_717123104 riff ;
   struct __anonstruct_fmt_947264284 fmt ;
   struct __anonstruct_data_947264285 data ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_WAV_ND_717123103 WAV_ND;
struct __anonstruct_riff_947264286 {
   U32___1 chunkID ;
   U32___1 chunkSize ;
   U32___1 format ;
} __attribute__((__packed__)) ;
struct __anonstruct_fmt_947264287 {
   U32___1 chunkID ;
   U32___1 chunkSize ;
   U16___1 audioFormat ;
   U16___1 numChannels ;
   U32___1 sampleRate ;
   U32___1 byteRate ;
   U16___1 blockAlign ;
   U16___1 bitsPerSample ;
   U16___1 dummy ;
} __attribute__((__packed__)) ;
struct __anonstruct_data_138372828 {
   U32___1 chunkID ;
   U32___1 chunkSize ;
   U32___1 numSamples ;
   U32___1 data_chunkID ;
   U32___1 data_chunkSize ;
   U8___1 data[] ;
} __attribute__((__packed__)) ;
struct __anonstruct_WAV_FACT_433279507 {
   struct __anonstruct_riff_947264286 riff ;
   struct __anonstruct_fmt_947264287 fmt ;
   struct __anonstruct_data_138372828 data ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_WAV_FACT_433279507 WAV_FACT;
struct __anonstruct_riff_947264288 {
   U32___1 chunkID ;
   U32___1 chunkSize ;
   U32___1 format ;
} __attribute__((__packed__)) ;
struct __anonstruct_fmt_947264289 {
   U32___1 chunkID ;
   U32___1 chunkSize ;
   U16___1 audioFormat ;
   U16___1 numChannels ;
   U32___1 sampleRate ;
   U32___1 byteRate ;
   U16___1 blockAlign ;
   U16___1 bitsPerSample ;
   U16___1 dummy ;
} __attribute__((__packed__)) ;
struct __anonstruct_data_947264290 {
   U32___1 chunkID ;
   U32___1 chunkSize ;
   U8___1 data[] ;
} __attribute__((__packed__)) ;
struct __anonstruct_WAV_NL_649910766 {
   struct __anonstruct_riff_947264288 riff ;
   struct __anonstruct_fmt_947264289 fmt ;
   struct __anonstruct_data_947264290 data ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_WAV_NL_649910766 WAV_NL;
struct __anonstruct_fileHeader_706858178 {
   U16___1 type ;
   U32___1 size ;
   U16___1 reserved1 ;
   U16___1 reserved2 ;
   U32___1 offset ;
} __attribute__((__packed__)) ;
struct __anonstruct_infoHeader_110306387 {
   U32___1 size ;
   S32___0 width ;
   S32___0 height ;
   U16___1 planes ;
   U16___1 bits ;
   U32___1 compression ;
   U32___1 imagesize ;
   S32___0 xresolution ;
   S32___0 yresolution ;
   U32___1 ncolours ;
   U32___1 importantcolours ;
} __attribute__((__packed__)) ;
struct __anonstruct_rgb_846263947 {
   U8___1 blue ;
   U8___1 green ;
   U8___1 red ;
   U8___1 reserved ;
} __attribute__((__packed__)) ;
struct __anonstruct_BMP_621040705 {
   struct __anonstruct_fileHeader_706858178 fileHeader ;
   struct __anonstruct_infoHeader_110306387 infoHeader ;
   struct __anonstruct_rgb_846263947 rgb ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_BMP_621040705 BMP;
struct __anonstruct_NXTCOLORSENSOR_T_371327434 {
   U16___1 color ;
   S16___0 rgb[3] ;
   U16___1 light ;
   U8___1 volatile   mode ;
   U8___1 volatile   mode_state ;
   U8___1 volatile   port_in_use ;
};
typedef struct __anonstruct_NXTCOLORSENSOR_T_371327434 NXTCOLORSENSOR_T;
typedef unsigned char U8___2;
typedef signed char S8___1;
typedef unsigned short U16___2;
typedef unsigned long U32___2;
typedef unsigned long size_t___0;
struct __anonstruct_to_avr_432250394 {
   U8___2 power ;
   U8___2 pwm_frequency ;
   S8___1 output_percent[4] ;
   U8___2 output_mode ;
   U8___2 input_power ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_to_avr_432250394 to_avr;
struct __anonstruct_from_avr_708559676 {
   U16___2 adc_value[4] ;
   U16___2 buttonsVal ;
   U16___2 extra ;
   U8___2 csum ;
} __attribute__((__packed__)) ;
typedef struct __anonstruct_from_avr_708559676 from_avr;
struct __anonstruct_nxt_avr_stats_680423455 {
   U32___2 good_rx ;
   U32___2 bad_rx ;
   U32___2 resets ;
   U32___2 still_busy ;
   U32___2 not_ok ;
};
typedef unsigned long U32___3;
typedef unsigned int AT91_REG___1;
struct motor_struct {
   int current_count ;
   int target_count ;
   int speed_percent ;
   U32___3 last ;
};
typedef unsigned char UINT8;
typedef UINT8 StatusType;
typedef UINT8 ResourceType;
typedef unsigned char U8___3;
typedef unsigned short U16___3;
typedef unsigned long U32___4;
typedef long S32___1;
struct dc_t {
   U32___4 duration ;
   S32___1 speed_left ;
   S32___1 speed_right ;
   int priority ;
};
void display_init(void) ;
void display_update(void) ;
void display_force_update(void) ;
void display_clear(U32 updateToo ) ;
void display_goto_xy(int x , int y ) ;
void display_char(int c ) ;
void display_string(char const   *str ) ;
void display_int(int val , U32 places ) ;
void display_hex(U32 val , U32 places ) ;
void display_unsigned(U32 val , U32 places ) ;
void display_bitmap_copy(U8 const   *data , U32 width , U32 depth , U32 x , U32 y ) ;
void display_test(void) ;
U8 *display_get_buffer(void) ;
void display_set_auto_update(int mode___0 ) ;
int display_tick ;
int display_auto_update ;
void nxt_lcd_init(U8 const   *disp ) ;
void nxt_lcd_power_up(void) ;
void nxt_lcd_power_down(void) ;
void nxt_lcd_update(void) ;
void nxt_lcd_force_update(void) ;
extern unsigned long systick_get_ms(void) ;
extern void systick_wait_ms(U32 ms ) ;
void nxt_spi_init(void) ;
void nxt_spi_write(U32 CD , U8 const   *dataM___0 , U32 nBytes ) ;
void nxt_spi_set_display(U8 const   *disp ) ;
void nxt_spi_refresh(void) ;
extern int interrupts_get_and_disable(void) ;
extern void interrupts_enable(void) ;
extern void aic_set_vector(unsigned long vector , unsigned long mode , unsigned long isr ) ;
extern void aic_mask_on(unsigned long vector ) ;
extern void aic_mask_off(unsigned long vector ) ;
U8 const   *displayM  =    (U8 const   *)((U8 *)0);
unsigned char volatile   dirty  =    (U8 volatile   )0;
unsigned char volatile   page  =    (U8 volatile   )0;
U8 const volatile   *dataM  =    (U8 const volatile   *)((U8 *)0);
U8 mode  =    (U8 )255;
extern void spi_isr_entry(void) ;
/*static void spi_set_mode(U8 m ) 
{ 
  U32 status ;

  {
  if ((int )m == (int )mode) {
    return;
  }
  while (1) {
    status = (U32 )*((AT91_REG *)4294836240U);
    if (! (! (status & 512UL))) {
      break;
    }
  }
  if (m) {
    *((AT91_REG *)4294964272U) = (AT91_REG )(1 << 12);
  } else {
    *((AT91_REG *)4294964276U) = (AT91_REG )(1 << 12);
  }
  mode = m;
  return;
}
}
void spi_isr_C(void) 
{ 


  {
  if ((int volatile   )page == (int volatile   )0) {
    if ((int volatile   )dirty != (int volatile   )0) {
      dataM = (U8 const volatile   *)displayM;
      dirty = (unsigned char volatile   )0;
    } else {
      *((AT91_REG *)4294836248U) = (AT91_REG )(1U << 5);
      return;
    }
  }
  spi_set_mode((U8 )1);
  *((AT91_REG *)4294836504U) = (AT91_REG )((U32 )dataM);
  *((AT91_REG *)4294836508U) = (AT91_REG )132;
  page = (unsigned char volatile   )(((int volatile   )page + (int volatile   )1) % (int volatile   )8);
  dataM += 100;
  return;
}
}
void nxt_spi_init(void) 
{ 
  int i_state ;
  int tmp ;

  {
  tmp = interrupts_get_and_disable();
  i_state = tmp;
  *((AT91_REG *)4294966288U) = (AT91_REG )(1L << 5U);
  *((AT91_REG *)4294964224U) = (AT91_REG )(1U << 12);
  *((AT91_REG *)4294964240U) = (AT91_REG )(1U << 12);
  *((AT91_REG *)4294964276U) = (AT91_REG )(1U << 12);
  *((AT91_REG *)4294964228U) = (AT91_REG )(1U << 14);
  *((AT91_REG *)4294964336U) = (AT91_REG )(1U << 14);
  *((AT91_REG *)4294964244U) = (AT91_REG )(1U << 14);
  *((AT91_REG *)4294964384U) = (AT91_REG )(1U << 14);
  *((AT91_REG *)4294964308U) = (AT91_REG )(1U << 14);
  *((AT91_REG *)4294964320U) = (AT91_REG )(1U << 14);
  *((AT91_REG *)4294964260U) = (AT91_REG )(1U << 14);
  *((AT91_REG *)4294964276U) = (AT91_REG )(1U << 14);
  *((AT91_REG *)4294964292U) = (AT91_REG )(1U << 14);
  *((AT91_REG *)4294964228U) = (AT91_REG )(1U << 13);
  *((AT91_REG *)4294964336U) = (AT91_REG )(1U << 13);
  *((AT91_REG *)4294964244U) = (AT91_REG )(1U << 13);
  *((AT91_REG *)4294964384U) = (AT91_REG )(1U << 13);
  *((AT91_REG *)4294964308U) = (AT91_REG )(1U << 13);
  *((AT91_REG *)4294964320U) = (AT91_REG )(1U << 13);
  *((AT91_REG *)4294964260U) = (AT91_REG )(1U << 13);
  *((AT91_REG *)4294964276U) = (AT91_REG )(1U << 13);
  *((AT91_REG *)4294964292U) = (AT91_REG )(1U << 13);
  *((AT91_REG *)4294964228U) = (AT91_REG )(1U << 10);
  *((AT91_REG *)4294964340U) = (AT91_REG )(1U << 10);
  *((AT91_REG *)4294964244U) = (AT91_REG )(1U << 10);
  *((AT91_REG *)4294964384U) = (AT91_REG )(1U << 10);
  *((AT91_REG *)4294964308U) = (AT91_REG )(1U << 10);
  *((AT91_REG *)4294964320U) = (AT91_REG )(1U << 10);
  *((AT91_REG *)4294964260U) = (AT91_REG )(1U << 10);
  *((AT91_REG *)4294964276U) = (AT91_REG )(1U << 10);
  *((AT91_REG *)4294964292U) = (AT91_REG )(1U << 10);
  *((AT91_REG *)4294836224U) = (AT91_REG )(1U << 7);
  *((AT91_REG *)4294836224U) = (AT91_REG )1U;
  *((AT91_REG *)4294836228U) = (AT91_REG )((1U | (1U << 4)) | (unsigned int )(11 << 16));
  *((AT91_REG *)4294836272U + 2) = (AT91_REG )((unsigned int )(24 << 8) | 1U);
  mode = (U8 )255;
  displayM = (U8 const   *)((U8 *)0);
  dataM = (U8 const volatile   *)displayM;
  dirty = (unsigned char volatile   )0;
  page = (unsigned char volatile   )0;
  aic_mask_off((U32 )5);
  aic_set_vector((U32 )5, (U32 )4, (U32 )(& spi_isr_entry));
  aic_mask_on((U32 )5);
  *((AT91_REG *)4294836512U) = (AT91_REG )(1U << 8);
  if (i_state) {
    interrupts_enable();
  }
  return;
}
}
void nxt_spi_write(U32 CD , U8 const   *dataM___0 , U32 nBytes ) 
{ 
  U32 status ;
  U32 cd_mask ;
  int tmp ;

  {
  if (CD) {
    tmp = 256;
  } else {
    tmp = 0;
  }
  cd_mask = (U32 )tmp;
  spi_set_mode((U8 )CD);
  while (nBytes) {
    *((AT91_REG *)4294836236U) = (AT91_REG )((unsigned long )*dataM___0 | cd_mask);
    dataM___0 ++;
    nBytes --;
    while (1) {
      status = (U32 )*((AT91_REG *)4294836240U);
      if (! (! (status & 512UL))) {
        break;
      }
    }
  }
  return;
}
}
void nxt_spi_set_display(U8 const   *disp ) 
{ 


  {
  if (! displayM) {
    displayM = disp;
  }
  return;
}
}
void nxt_spi_refresh(void) 
{ 


  {
  if (! displayM) {
    return;
  }
  dirty = (unsigned char volatile   )1;
  *((AT91_REG *)4294836244U) = (AT91_REG )(1U << 5);
  return;
}
}
int nxt_motor_get_count(unsigned long n ) ;
void nxt_motor_set_count(unsigned long n , int count ) ;
extern void nxt_motor_set_speed(unsigned long n , int speed_percent , int brake ) ;
void nxt_motor_command(unsigned long n , int cmd , int target_count , int speed_percent ) ;
void nxt_motor_init(void) ;
void nxt_motor_1kHz_process(void) ;
void nxt_avr_init(void) ;
void nxt_avr_1kHz_update(void) ;
void nxt_avr_power_down(void) ;
unsigned long buttons_get(void) ;
unsigned long battery_voltage(void) ;
unsigned long sensor_adc(unsigned long n ) ;
void nxt_avr_set_input_power(unsigned long n , unsigned long power_type ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               unsigned long __n ) ;
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
static U8 *display  =    (U8 *)0;
void nxt_lcd_command(U8 cmd ) 
{ 
  U8 tmp ;

  {
  tmp = cmd;
  nxt_spi_write((U32 )0, (U8 const   *)(& tmp), (U32 )1);
  return;
}
}
void nxt_lcd_set_col(U32 coladdr ) 
{ 


  {
  nxt_lcd_command((U8 )(coladdr & 15UL));
  nxt_lcd_command((U8 )(16UL | ((coladdr >> 4) & 15UL)));
  return;
}
}
void nxt_lcd_set_multiplex_rate(U32 mr ) 
{ 


  {
  nxt_lcd_command((U8 )(32UL | (mr & 3UL)));
  return;
}
}
void nxt_lcd_set_temp_comp(U32 tc ) 
{ 


  {
  nxt_lcd_command((U8 )(36UL | (tc & 3UL)));
  return;
}
}
void nxt_lcd_set_panel_loading(U32 hi ) 
{ 
  int tmp ;

  {
  if (hi) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  nxt_lcd_command((U8 )(40 | tmp));
  return;
}
}
void nxt_lcd_set_pump_control(U32 pc ) 
{ 
  {
  nxt_lcd_command((U8 )(44UL | (pc & 3UL)));
  return;
}
}
void nxt_lcd_set_scroll_line(U32 sl ) 
{ 
  {
  nxt_lcd_command((U8 )(64UL | (sl & 63UL)));
  return;
}
}
void nxt_lcd_set_page_address(U32 pa ) 
{
  {
  nxt_lcd_command((U8 )(176UL | (pa & 15UL)));
  return;
}
}
void nxt_lcd_set_pot(U32 pot ) 
{ 


  {
  nxt_lcd_command((U8 )129);
  nxt_lcd_command((U8 )(pot & 255UL));
  return;
}
}
void nxt_lcd_set_ram_address_control(U32 ac ) 
{ 


  {
  nxt_lcd_command((U8 )(136UL | (ac & 7UL)));
  return;
}
}
void nxt_lcd_set_frame_rate(U32 fr ) 
{ 


  {
  nxt_lcd_command((U8 )(160UL | (fr & 1UL)));
  return;
}
}
void nxt_lcd_set_all_pixels_on(U32 on ) 
{ 
  int tmp ;

  {
  if (on) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  nxt_lcd_command((U8 )(164 | tmp));
  return;
}
}
void nxt_lcd_inverse_display(U32 on ) 
{ 
  int tmp ;

  {
  if (on) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  nxt_lcd_command((U8 )(166 | tmp));
  return;
}
}
void nxt_lcd_enable(U32 on ) 
{ 
  int tmp ;

  {
  if (on) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  nxt_lcd_command((U8 )(174 | tmp));
  return;
}
}
void nxt_lcd_set_map_control(U32 map_control ) 
{ 


  {
  nxt_lcd_command((U8 )(192UL | ((map_control & 3UL) << 1)));
  return;
}
}
void nxt_lcd_reset(void) 
{ 


  {
  nxt_lcd_command((U8 )226);
  return;
}
}
void nxt_lcd_set_bias_ratio(U32 ratio ) 
{ 


  {
  nxt_lcd_command((U8 )(232UL | (ratio & 3UL)));
  return;
}
}
void nxt_lcd_set_cursor_update(U32 on ) 
{ 
  int tmp ;

  {
  if (on) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  nxt_lcd_command((U8 )(238 | tmp));
  return;
}
}
void nxt_lcd_force_update(void) 
{ 
  int i ;
  U8 *disp ;

  {
  disp = display;
  i = 0;
  while (i < 8) {
    nxt_lcd_set_col((U32 )0);
    nxt_lcd_set_page_address((U32 )i);
    nxt_spi_write((U32 )1, (U8 const   *)disp, (U32 )100);
    disp += 100;
    i ++;
  }
  return;
}
}
void nxt_lcd_update(void) 
{ 


  {
  nxt_spi_refresh();
  return;
}
}
void nxt_lcd_power_up(void) 
{ 


  {
  systick_wait_ms((U32 )20);
  nxt_lcd_reset();
  systick_wait_ms((U32 )20);
  nxt_lcd_set_multiplex_rate((U32 )3);
  nxt_lcd_set_bias_ratio((U32 )3);
  nxt_lcd_set_pot((U32 )96);
  nxt_lcd_set_ram_address_control((U32 )1);
  nxt_lcd_set_map_control((U32 )2);
  nxt_spi_set_display((U8 const   *)display);
  nxt_lcd_enable((U32 )1);
  return;
}
}
void nxt_lcd_power_down(void) 
{ 


  {
  nxt_lcd_reset();
  return;
}
}
void nxt_lcd_init(U8 const   *disp ) 
{ 


  {
  display = (U8 *)disp;
  nxt_spi_init();
  nxt_lcd_power_up();
  return;
}
}
static struct __anonstruct_display_array_740464799 display_array  ;
static U8 (*display_buffer)[100]  =    display_array.displayN;
static U8 const   font[128][5]  = 
  { {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )85,        (U8 const   )97,        (U8 const   )85, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )107,        (U8 const   )95,        (U8 const   )107, 
            (U8 const   )62}, 
   {        (U8 const   )12,        (U8 const   )30,        (U8 const   )60,        (U8 const   )30, 
            (U8 const   )12}, 
   {        (U8 const   )8,        (U8 const   )28,        (U8 const   )62,        (U8 const   )28, 
            (U8 const   )8}, 
   {        (U8 const   )24,        (U8 const   )94,        (U8 const   )126,        (U8 const   )94, 
            (U8 const   )24}, 
   {        (U8 const   )24,        (U8 const   )92,        (U8 const   )126,        (U8 const   )92, 
            (U8 const   )24}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}, 
   {        (U8 const   )0,        (U8 const   )0,        (U8 const   )0,        (U8 const   )0, 
            (U8 const   )0}, 
   {        (U8 const   )0,        (U8 const   )0,        (U8 const   )95,        (U8 const   )0, 
            (U8 const   )0}, 
   {        (U8 const   )0,        (U8 const   )7,        (U8 const   )0,        (U8 const   )7, 
            (U8 const   )0}, 
   {        (U8 const   )20,        (U8 const   )62,        (U8 const   )20,        (U8 const   )62, 
            (U8 const   )20}, 
   {        (U8 const   )4,        (U8 const   )42,        (U8 const   )127,        (U8 const   )42, 
            (U8 const   )16}, 
   {        (U8 const   )38,        (U8 const   )22,        (U8 const   )8,        (U8 const   )52, 
            (U8 const   )50}, 
   {        (U8 const   )54,        (U8 const   )73,        (U8 const   )89,        (U8 const   )38, 
            (U8 const   )80}, 
   {        (U8 const   )0,        (U8 const   )0,        (U8 const   )7,        (U8 const   )0, 
            (U8 const   )0}, 
   {        (U8 const   )0,        (U8 const   )28,        (U8 const   )34,        (U8 const   )65, 
            (U8 const   )0}, 
   {        (U8 const   )0,        (U8 const   )65,        (U8 const   )34,        (U8 const   )28, 
            (U8 const   )0}, 
   {        (U8 const   )42,        (U8 const   )28,        (U8 const   )127,        (U8 const   )28, 
            (U8 const   )42}, 
   {        (U8 const   )8,        (U8 const   )8,        (U8 const   )62,        (U8 const   )8, 
            (U8 const   )8}, 
   {        (U8 const   )0,        (U8 const   )80,        (U8 const   )48,        (U8 const   )0, 
            (U8 const   )0}, 
   {        (U8 const   )8,        (U8 const   )8,        (U8 const   )8,        (U8 const   )8, 
            (U8 const   )8}, 
   {        (U8 const   )0,        (U8 const   )96,        (U8 const   )96,        (U8 const   )0, 
            (U8 const   )0}, 
   {        (U8 const   )32,        (U8 const   )16,        (U8 const   )8,        (U8 const   )4, 
            (U8 const   )2}, 
   {        (U8 const   )62,        (U8 const   )81,        (U8 const   )73,        (U8 const   )69, 
            (U8 const   )62}, 
   {        (U8 const   )0,        (U8 const   )66,        (U8 const   )127,        (U8 const   )64, 
            (U8 const   )0}, 
   {        (U8 const   )66,        (U8 const   )97,        (U8 const   )81,        (U8 const   )73, 
            (U8 const   )70}, 
   {        (U8 const   )33,        (U8 const   )65,        (U8 const   )69,        (U8 const   )75, 
            (U8 const   )49}, 
   {        (U8 const   )24,        (U8 const   )20,        (U8 const   )18,        (U8 const   )127, 
            (U8 const   )16}, 
   {        (U8 const   )39,        (U8 const   )69,        (U8 const   )69,        (U8 const   )69, 
            (U8 const   )57}, 
   {        (U8 const   )60,        (U8 const   )74,        (U8 const   )73,        (U8 const   )73, 
            (U8 const   )48}, 
   {        (U8 const   )1,        (U8 const   )1,        (U8 const   )121,        (U8 const   )5, 
            (U8 const   )3}, 
   {        (U8 const   )54,        (U8 const   )73,        (U8 const   )73,        (U8 const   )73, 
            (U8 const   )54}, 
   {        (U8 const   )6,        (U8 const   )73,        (U8 const   )73,        (U8 const   )41, 
            (U8 const   )30}, 
   {        (U8 const   )0,        (U8 const   )54,        (U8 const   )54,        (U8 const   )0, 
            (U8 const   )0}, 
   {        (U8 const   )0,        (U8 const   )86,        (U8 const   )54,        (U8 const   )0, 
            (U8 const   )0}, 
   {        (U8 const   )8,        (U8 const   )20,        (U8 const   )34,        (U8 const   )65, 
            (U8 const   )0}, 
   {        (U8 const   )20,        (U8 const   )20,        (U8 const   )20,        (U8 const   )20, 
            (U8 const   )20}, 
   {        (U8 const   )65,        (U8 const   )34,        (U8 const   )20,        (U8 const   )8, 
            (U8 const   )0}, 
   {        (U8 const   )2,        (U8 const   )1,        (U8 const   )89,        (U8 const   )5, 
            (U8 const   )2}, 
   {        (U8 const   )28,        (U8 const   )42,        (U8 const   )54,        (U8 const   )62, 
            (U8 const   )12}, 
   {        (U8 const   )126,        (U8 const   )9,        (U8 const   )9,        (U8 const   )9, 
            (U8 const   )126}, 
   {        (U8 const   )127,        (U8 const   )73,        (U8 const   )73,        (U8 const   )73, 
            (U8 const   )62}, 
   {        (U8 const   )62,        (U8 const   )65,        (U8 const   )65,        (U8 const   )65, 
            (U8 const   )34}, 
   {        (U8 const   )127,        (U8 const   )65,        (U8 const   )65,        (U8 const   )34, 
            (U8 const   )28}, 
   {        (U8 const   )127,        (U8 const   )73,        (U8 const   )73,        (U8 const   )73, 
            (U8 const   )65}, 
   {        (U8 const   )127,        (U8 const   )9,        (U8 const   )9,        (U8 const   )9, 
            (U8 const   )1}, 
   {        (U8 const   )62,        (U8 const   )65,        (U8 const   )65,        (U8 const   )73, 
            (U8 const   )58}, 
   {        (U8 const   )127,        (U8 const   )8,        (U8 const   )8,        (U8 const   )8, 
            (U8 const   )127}, 
   {        (U8 const   )0,        (U8 const   )65,        (U8 const   )127,        (U8 const   )65, 
            (U8 const   )0}, 
   {        (U8 const   )32,        (U8 const   )64,        (U8 const   )65,        (U8 const   )63, 
            (U8 const   )1}, 
   {        (U8 const   )127,        (U8 const   )8,        (U8 const   )20,        (U8 const   )34, 
            (U8 const   )65}, 
   {        (U8 const   )127,        (U8 const   )64,        (U8 const   )64,        (U8 const   )64, 
            (U8 const   )64}, 
   {        (U8 const   )127,        (U8 const   )2,        (U8 const   )4,        (U8 const   )2, 
            (U8 const   )127}, 
   {        (U8 const   )127,        (U8 const   )4,        (U8 const   )8,        (U8 const   )16, 
            (U8 const   )127}, 
   {        (U8 const   )62,        (U8 const   )65,        (U8 const   )65,        (U8 const   )65, 
            (U8 const   )62}, 
   {        (U8 const   )127,        (U8 const   )9,        (U8 const   )9,        (U8 const   )9, 
            (U8 const   )6}, 
   {        (U8 const   )62,        (U8 const   )65,        (U8 const   )81,        (U8 const   )33, 
            (U8 const   )94}, 
   {        (U8 const   )127,        (U8 const   )9,        (U8 const   )25,        (U8 const   )41, 
            (U8 const   )70}, 
   {        (U8 const   )38,        (U8 const   )73,        (U8 const   )73,        (U8 const   )73, 
            (U8 const   )50}, 
   {        (U8 const   )1,        (U8 const   )1,        (U8 const   )127,        (U8 const   )1, 
            (U8 const   )1}, 
   {        (U8 const   )63,        (U8 const   )64,        (U8 const   )64,        (U8 const   )64, 
            (U8 const   )63}, 
   {        (U8 const   )31,        (U8 const   )32,        (U8 const   )64,        (U8 const   )32, 
            (U8 const   )31}, 
   {        (U8 const   )127,        (U8 const   )32,        (U8 const   )24,        (U8 const   )32, 
            (U8 const   )127}, 
   {        (U8 const   )99,        (U8 const   )20,        (U8 const   )8,        (U8 const   )20, 
            (U8 const   )99}, 
   {        (U8 const   )3,        (U8 const   )4,        (U8 const   )120,        (U8 const   )4, 
            (U8 const   )3}, 
   {        (U8 const   )97,        (U8 const   )81,        (U8 const   )73,        (U8 const   )69, 
            (U8 const   )67}, 
   {        (U8 const   )0,        (U8 const   )127,        (U8 const   )65,        (U8 const   )65, 
            (U8 const   )0}, 
   {        (U8 const   )2,        (U8 const   )4,        (U8 const   )8,        (U8 const   )16, 
            (U8 const   )32}, 
   {        (U8 const   )0,        (U8 const   )65,        (U8 const   )65,        (U8 const   )127, 
            (U8 const   )0}, 
   {        (U8 const   )4,        (U8 const   )2,        (U8 const   )1,        (U8 const   )2, 
            (U8 const   )4}, 
   {        (U8 const   )64,        (U8 const   )64,        (U8 const   )64,        (U8 const   )64, 
            (U8 const   )64}, 
   {        (U8 const   )0,        (U8 const   )0,        (U8 const   )7,        (U8 const   )0, 
            (U8 const   )0}, 
   {        (U8 const   )32,        (U8 const   )84,        (U8 const   )84,        (U8 const   )84, 
            (U8 const   )120}, 
   {        (U8 const   )127,        (U8 const   )72,        (U8 const   )68,        (U8 const   )68, 
            (U8 const   )56}, 
   {        (U8 const   )48,        (U8 const   )72,        (U8 const   )72,        (U8 const   )72, 
            (U8 const   )32}, 
   {        (U8 const   )56,        (U8 const   )68,        (U8 const   )68,        (U8 const   )72, 
            (U8 const   )127}, 
   {        (U8 const   )56,        (U8 const   )84,        (U8 const   )84,        (U8 const   )84, 
            (U8 const   )24}, 
   {        (U8 const   )8,        (U8 const   )126,        (U8 const   )9,        (U8 const   )9, 
            (U8 const   )2}, 
   {        (U8 const   )12,        (U8 const   )82,        (U8 const   )82,        (U8 const   )82, 
            (U8 const   )62}, 
   {        (U8 const   )127,        (U8 const   )8,        (U8 const   )4,        (U8 const   )4, 
            (U8 const   )120}, 
   {        (U8 const   )0,        (U8 const   )68,        (U8 const   )125,        (U8 const   )64, 
            (U8 const   )0}, 
   {        (U8 const   )32,        (U8 const   )64,        (U8 const   )64,        (U8 const   )61, 
            (U8 const   )0}, 
   {        (U8 const   )127,        (U8 const   )16,        (U8 const   )40,        (U8 const   )68, 
            (U8 const   )0}, 
   {        (U8 const   )0,        (U8 const   )65,        (U8 const   )127,        (U8 const   )64, 
            (U8 const   )0}, 
   {        (U8 const   )124,        (U8 const   )4,        (U8 const   )24,        (U8 const   )4, 
            (U8 const   )120}, 
   {        (U8 const   )124,        (U8 const   )8,        (U8 const   )4,        (U8 const   )4, 
            (U8 const   )120}, 
   {        (U8 const   )56,        (U8 const   )68,        (U8 const   )68,        (U8 const   )68, 
            (U8 const   )56}, 
   {        (U8 const   )252,        (U8 const   )20,        (U8 const   )20,        (U8 const   )20, 
            (U8 const   )8}, 
   {        (U8 const   )8,        (U8 const   )20,        (U8 const   )20,        (U8 const   )24, 
            (U8 const   )124}, 
   {        (U8 const   )124,        (U8 const   )8,        (U8 const   )4,        (U8 const   )4, 
            (U8 const   )8}, 
   {        (U8 const   )72,        (U8 const   )84,        (U8 const   )84,        (U8 const   )84, 
            (U8 const   )32}, 
   {        (U8 const   )4,        (U8 const   )63,        (U8 const   )68,        (U8 const   )64, 
            (U8 const   )32}, 
   {        (U8 const   )60,        (U8 const   )64,        (U8 const   )64,        (U8 const   )32, 
            (U8 const   )124}, 
   {        (U8 const   )28,        (U8 const   )32,        (U8 const   )64,        (U8 const   )32, 
            (U8 const   )28}, 
   {        (U8 const   )60,        (U8 const   )64,        (U8 const   )56,        (U8 const   )64, 
            (U8 const   )60}, 
   {        (U8 const   )68,        (U8 const   )40,        (U8 const   )16,        (U8 const   )40, 
            (U8 const   )68}, 
   {        (U8 const   )12,        (U8 const   )80,        (U8 const   )80,        (U8 const   )80, 
            (U8 const   )60}, 
   {        (U8 const   )68,        (U8 const   )100,        (U8 const   )84,        (U8 const   )76, 
            (U8 const   )68}, 
   {        (U8 const   )0,        (U8 const   )8,        (U8 const   )54,        (U8 const   )65, 
            (U8 const   )0}, 
   {        (U8 const   )0,        (U8 const   )0,        (U8 const   )127,        (U8 const   )0, 
            (U8 const   )0}, 
   {        (U8 const   )0,        (U8 const   )65,        (U8 const   )54,        (U8 const   )8, 
            (U8 const   )0}, 
   {        (U8 const   )0,        (U8 const   )7,        (U8 const   )0,        (U8 const   )7, 
            (U8 const   )0}, 
   {        (U8 const   )62,        (U8 const   )54,        (U8 const   )42,        (U8 const   )54, 
            (U8 const   )62}};
int display_tick  =    0;
int display_auto_update  =    1;
void display_update(void) 
{ 


  {
  display_tick = 0;
  nxt_lcd_update();
  return;
}
}
void display_set_auto_update(int mode___0 ) 
{ 


  {
  display_auto_update = mode___0;
  return;
}
}
void display_force_update(void) 
{ 


  {
  nxt_lcd_force_update();
  return;
}
}
void display_clear(U32 updateToo ) 
{ 


  {
  memset((void *)display_buffer, 0, (size_t )800);
  if (updateToo) {
    display_update();
  }
  return;
}
}*/
int display_x  ;
int display_y  ;
/*
void display_char(int c ) 
{ 
  int i ;
  U8 *b ;
  U8 const   *f ;

  {
  if (c >= 0) {
    if (c < 128) {
      if (display_x >= 0) {
        if (display_x < 16) {
          if (display_y >= 0) {
            if (display_y < 8) {
              b = & (*(display_buffer + display_y))[display_x * 6];
              f = font[c];
              i = 0;
              while (i < 5) {
                *b = (U8 )*f;
                b ++;
                f ++;
                i ++;
              }
            }
          }
        }
      }
    }
  }
  return;
}
}

void display_hex(U32 val , U32 places ) 
{ 
  char x[9] ;
  char *p ;
  int p_count ;
  char const   *str6 ;

  {
  p = & x[8];
  p_count = 0;
  *p = (char)0;
  if (places > 8UL) {
    places = (U32 )8;
  }
  while (val) {
    p --;
    p_count ++;
    *p = (char )*("0123456789ABCDEF" + (val & 15UL));
    val >>= 4;
  }
  while ((U32 )p_count < places) {
    p --;
    p_count ++;
    *p = (char )'0';
  }
  str6 = (char const   *)p;
  while (*str6) {
    if ((int const   )*str6 != 10) {
      display_char((int )*str6);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str6 ++;
  }
  goto Lret_display_string;
  Lret_display_string: ;
  return;
}
}
static void display_unsigned_worker(U32 val , U32 places , U32 sign ) 
{ 
  char x[12] ;
  char *p ;
  int p_count ;
  char const   *str7 ;

  {
  p = & x[11];
  p_count = 0;
  *p = (char)0;
  if (places > 11UL) {
    places = (U32 )11;
  }
  while (val) {
    p --;
    p_count ++;
    *p = (char )(val % 10UL + 48UL);
    val /= 10UL;
  }
  if (! p_count) {
    p --;
    p_count ++;
    *p = (char )'0';
  }
  if (sign) {
    p --;
    p_count ++;
    *p = (char )'-';
  }
  while ((U32 )p_count < places) {
    p --;
    p_count ++;
    *p = (char )' ';
  }
  str7 = (char const   *)p;
  while (*str7) {
    if ((int const   )*str7 != 10) {
      display_char((int )*str7);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str7 ++;
  }
  goto Lret_display_string;
  Lret_display_string: ;
  return;
}
}
void display_unsigned(U32 val , U32 places ) 
{ 


  {
  display_unsigned_worker(val, places, (U32 )0);
  return;
}
}

void display_bitmap_copy(U8 const   *data , U32 width , U32 depth , U32 x , U32 y ) 
{ 
  U32 i ;
  U32 j ;
  U32 dy ;
  U32 dx ;

  {
  i = (U32 )0;
  while (i < depth) {
    j = (U32 )0;
    while (j < width) {
      dx = x + j;
      dy = y + i;
      if (dx < 100UL) {
        if (dy < 8UL) {
          (*(display_buffer + (y + i)))[x + j] = (U8 )*(data + (width * i + j));
        }
      }
      j ++;
    }
    i ++;
  }
  return;
}
}
U8 *display_get_buffer(void) 
{ 


  {
  return ((U8 *)display_buffer);
}
}
STACKWORD display_get_array(void) 
{ 


  {
  return ((STACKWORD )(& display_array));
}
}
void display_init(void) 
{ 


  {
  display_array.hdr.flags.arrays.isArray = (TWOBYTES )1;
  display_array.hdr.flags.arrays.mark = (TWOBYTES )1;
  display_array.hdr.flags.arrays.length = (TWOBYTES )200;
  display_array.hdr.flags.arrays.isAllocated = (TWOBYTES )1;
  display_array.hdr.flags.arrays.type = (TWOBYTES )10;
  display_array.hdr.monitorCount = (byte )0;
  display_array.hdr.threadId = (byte )0;
  display_clear((U32 )0);
  display_auto_update = 1;
  nxt_lcd_init((U8 const   *)((U8 *)display_buffer));
  return;
}
}
void display_test(void) 
{ 
  int iterator ;
  U32 tmp ;
  int x3 ;
  int y4 ;
  int x5 ;
  int y6 ;
  int x7 ;
  int y8 ;
  int x9 ;
  int y10 ;
  int x11 ;
  int y12 ;
  int x13 ;
  int y14 ;
  int x15 ;
  int y16 ;
  char const   *str17 ;
  char const   *str18 ;
  char const   *str19 ;
  char const   *str20 ;
  char const   *str21 ;
  char const   *str22 ;
  char const   *str23 ;

  {
  iterator = 0;
  nxt_lcd_init((U8 const   *)((U8 *)display_buffer));
  while (1) {
    display_clear((U32 )0);
    x3 = iterator;
    y4 = 0;
    display_x = x3;
    display_y = y4;
    goto Lret_display_goto_xy;
    Lret_display_goto_xy: 
    str17 = "LEJOS NXT";
    while (*str17) {
      if ((int const   )*str17 != 10) {
        display_char((int )*str17);
        display_x ++;
      } else {
        display_x = 0;
        display_y ++;
      }
      str17 ++;
    }
    goto Lret_display_string;
    Lret_display_string: 
    x5 = 0;
    y6 = 1;
    display_x = x5;
    display_y = y6;
    goto Lret_display_goto_xy___0;
    Lret_display_goto_xy___0: 
    str18 = "0123456789.:/";
    while (*str18) {
      if ((int const   )*str18 != 10) {
        display_char((int )*str18);
        display_x ++;
      } else {
        display_x = 0;
        display_y ++;
      }
      str18 ++;
    }
    goto Lret_display_string___0;
    Lret_display_string___0: 
    x7 = 0;
    y8 = 2;
    display_x = x7;
    display_y = y8;
    goto Lret_display_goto_xy___1;
    Lret_display_goto_xy___1: 
    str19 = "abcdefghijklm";
    while (*str19) {
      if ((int const   )*str19 != 10) {
        display_char((int )*str19);
        display_x ++;
      } else {
        display_x = 0;
        display_y ++;
      }
      str19 ++;
    }
    goto Lret_display_string___1;
    Lret_display_string___1: 
    x9 = 0;
    y10 = 3;
    display_x = x9;
    display_y = y10;
    goto Lret_display_goto_xy___2;
    Lret_display_goto_xy___2: 
    str20 = "nopqrstuvwxyz";
    while (*str20) {
      if ((int const   )*str20 != 10) {
        display_char((int )*str20);
        display_x ++;
      } else {
        display_x = 0;
        display_y ++;
      }
      str20 ++;
    }
    goto Lret_display_string___2;
    Lret_display_string___2: 
    x11 = 0;
    y12 = 4;
    display_x = x11;
    display_y = y12;
    goto Lret_display_goto_xy___3;
    Lret_display_goto_xy___3: 
    str21 = "ABCDEFGHIJKLM";
    while (*str21) {
      if ((int const   )*str21 != 10) {
        display_char((int )*str21);
        display_x ++;
      } else {
        display_x = 0;
        display_y ++;
      }
      str21 ++;
    }
    goto Lret_display_string___3;
    Lret_display_string___3: 
    x13 = 0;
    y14 = 5;
    display_x = x13;
    display_y = y14;
    goto Lret_display_goto_xy___4;
    Lret_display_goto_xy___4: 
    str22 = "NOPQRSTUVWXYZ";
    while (*str22) {
      if ((int const   )*str22 != 10) {
        display_char((int )*str22);
        display_x ++;
      } else {
        display_x = 0;
        display_y ++;
      }
      str22 ++;
    }
    goto Lret_display_string___4;
    Lret_display_string___4: 
    x15 = 0;
    y16 = 7;
    display_x = x15;
    display_y = y16;
    goto Lret_display_goto_xy___5;
    Lret_display_goto_xy___5: 
    str23 = "TIME ";
    while (*str23) {
      if ((int const   )*str23 != 10) {
        display_char((int )*str23);
        display_x ++;
      } else {
        display_x = 0;
        display_y ++;
      }
      str23 ++;
    }
    goto Lret_display_string___5;
    Lret_display_string___5: 
    tmp = systick_get_ms();
    display_unsigned(tmp, (U32 )0);
    iterator = (iterator + 1) & 7;
    display_update();
    systick_wait_ms((U32 )2000);
  }
}
}*/
void i2c_disable(int port ) ;
void i2c_enable(int port ) ;
void i2c_init(void) ;
int i2c_busy(int port ) ;
int i2c_start_transaction(int port , U32___0 address , int internal_address , int n_internal_address_bytes ,
                          U8___0 *data , U32___0 nbytes , int write ) ;
static struct i2c_pin_pair  const  i2c_pin[4]  = {      {(U32___0 )(1 << 23), (U32___0 )(1 << 18)}, 
        {(U32___0 )(1 << 28), (U32___0 )(1 << 19)}, 
        {(U32___0 )(1 << 29), (U32___0 )(1 << 20)}, 
        {(U32___0 )(1 << 30), (U32___0 )(1 << 2)}};
static struct i2c_port_struct i2c_port[4]  ;
static U32___0 i2c_int_count  ;
extern void i2c_timer_isr_entry(void) ;
/*
void i2c_timer_isr_C(void) 
{ 
  int i ;
  U32___0 codr ;
  U32___0 sodr ;
  U32___0 oer ;
  U32___0 odr ;
  U32___0 inputs ;
  struct i2c_port_struct *p ;
  U32___0 dummy ;
  U8___0 *d ;

  {
  codr = (U32___0 )0;
  sodr = (U32___0 )0;
  oer = (U32___0 )0;
  odr = (U32___0 )0;
  inputs = (U32___0 )*((AT91_REG___0 *)4294964284U);
  p = i2c_port;
  dummy = (U32___0 )*((AT91_REG___0 *)4294574112U);
  i2c_int_count ++;
  i = 0;
  while (i < 4) {
    while (1) {
      break;
    }
    switch ((unsigned int )p->state) {
    default: 
    break;
    case 1U: 
    break;
    case 2U: 
    p->pt_begun |= (unsigned long )(1 << p->pt_num);
    oer |= p->sda_pin;
    oer |= p->scl_pin;
    if (p->current_pt) {
      if ((p->current_pt)->nbytes) {
        p->data = (p->current_pt)->data;
        p->nbits = (U32___0 )((int )(p->current_pt)->nbytes * 8);
        p->transmitting = (U32___0 )(p->current_pt)->tx;
        p->ack_slot = (U32___0 )0;
        p->ack_slot_pending = (U32___0 )0;
        p->fault = (U32___0 )0;
        if (! p->transmitting) {
          *(p->data) = (U8___0 )0;
        }
        if ((p->current_pt)->restart) {
          sodr |= p->scl_pin;
          sodr |= p->sda_pin;
          p->state = (i2c_port_state )3;
        } else
        if ((p->current_pt)->start) {
          sodr |= p->sda_pin;
          p->state = (i2c_port_state )4;
        } else {
          codr |= p->scl_pin;
          p->state = (i2c_port_state )8;
        }
      } else {
        p->state = (i2c_port_state )1;
      }
    } else {
      p->state = (i2c_port_state )1;
    }
    break;
    case 3U: 
    codr |= p->scl_pin;
    p->state = (i2c_port_state )4;
    break;
    case 4U: 
    sodr |= p->scl_pin;
    p->state = (i2c_port_state )5;
    break;
    case 5U: 
    if (inputs & p->sda_pin) {
      codr |= p->sda_pin;
      p->state = (i2c_port_state )6;
    } else {
      codr |= p->scl_pin;
      p->state = (i2c_port_state )7;
    }
    break;
    case 7U: 
    codr |= p->scl_pin;
    p->state = (i2c_port_state )4;
    break;
    case 6U: 
    codr |= p->scl_pin;
    p->state = (i2c_port_state )8;
    break;
    case 8U: 
    if (p->ack_slot_pending) {
      p->ack_slot = (U32___0 )1;
      p->ack_slot_pending = (U32___0 )0;
    } else {
      p->ack_slot = (U32___0 )0;
    }
    if (p->nbits) {
      goto _L;
    } else
    if (p->ack_slot) {
      _L: 
      if (p->ack_slot) {
        if (p->transmitting) {
          odr |= p->sda_pin;
        } else {
          oer |= p->sda_pin;
          codr |= p->sda_pin;
        }
      } else
      if (! p->transmitting) {
        odr |= p->sda_pin;
      } else {
        oer |= p->sda_pin;
        (p->nbits) --;
        if (((int )*(p->data) >> (p->nbits & 7UL)) & 1) {
          sodr |= p->sda_pin;
        } else {
          codr |= p->sda_pin;
        }
        if ((p->nbits & 7UL) == 0UL) {
          (p->data) ++;
          if (p->nbits) {
            p->ack_slot_pending = (U32___0 )1;
          } else
          if (p->transmitting) {
            p->ack_slot_pending = (U32___0 )1;
          }
        }
      }
      p->state = (i2c_port_state )9;
    } else
    if ((p->current_pt)->stop) {
      p->state = (i2c_port_state )12;
    } else {
      (p->current_pt) ++;
      (p->pt_num) ++;
      sodr |= p->sda_pin;
      p->state = (i2c_port_state )2;
    }
    break;
    case 9U: 
    sodr |= p->scl_pin;
    p->state = (i2c_port_state )10;
    break;
    case 10U: 
    if (inputs & p->scl_pin) {
      p->state = (i2c_port_state )11;
    }
    break;
    case 11U: 
    if (p->transmitting) {
      if (p->ack_slot) {
        if (inputs & p->sda_pin) {
          (p->n_fault) ++;
          (p->ack_fail) ++;
          p->fault = (U32___0 )1;
          codr |= p->scl_pin;
          p->state = (i2c_port_state )12;
        } else {
          (p->ack_good) ++;
          codr |= p->scl_pin;
          p->state = (i2c_port_state )8;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if (! p->transmitting) {
        if (! p->ack_slot) {
          d = p->data;
          (p->nbits) --;
          if (inputs & p->sda_pin) {
            *d = (U8___0 )((int )*d | (1 << (p->nbits & 7UL)));
          }
          if (p->nbits) {
            if ((p->nbits & 7UL) == 0UL) {
              (p->data) ++;
              d = p->data;
              p->ack_slot_pending = (U32___0 )1;
              *d = (U8___0 )0;
            }
          }
        }
      }
      codr |= p->scl_pin;
      p->state = (i2c_port_state )8;
    }
    break;
    case 12U: 
    oer |= p->sda_pin;
    codr |= p->sda_pin;
    p->state = (i2c_port_state )13;
    break;
    case 13U: 
    sodr |= p->scl_pin;
    p->state = (i2c_port_state )14;
    break;
    case 14U: 
    sodr |= p->sda_pin;
    p->state = (i2c_port_state )15;
    break;
    case 15U: 
    if ((p->current_pt)->last_pt) {
      p->state = (i2c_port_state )1;
    } else {
      (p->current_pt) ++;
      (p->pt_num) ++;
      p->state = (i2c_port_state )2;
    }
    }
    p ++;
    i ++;
  }
  if (codr) {
    *((AT91_REG___0 *)4294964276U) = (AT91_REG___0 )codr;
  }
  if (sodr) {
    *((AT91_REG___0 *)4294964272U) = (AT91_REG___0 )sodr;
  }
  if (oer) {
    *((AT91_REG___0 *)4294964240U) = (AT91_REG___0 )oer;
  }
  if (odr) {
    *((AT91_REG___0 *)4294964244U) = (AT91_REG___0 )odr;
  }
  return;
}
}
void i2c_disable(int port ) 
{ 
  struct i2c_port_struct *p ;
  U32___0 pinmask ;

  {
  if (port >= 0) {
    if (port < 4) {
      p = & i2c_port[port];
      pinmask = p->scl_pin | p->sda_pin;
      *((AT91_REG___0 *)4294964244U) = (AT91_REG___0 )pinmask;
    }
  }
  return;
}
}
void i2c_enable(int port ) 
{ 
  struct i2c_port_struct *p ;
  U32___0 pinmask ;

  {
  if (port >= 0) {
    if (port < 4) {
      p = & i2c_port[port];
      pinmask = p->scl_pin | p->sda_pin;
      p->state = (i2c_port_state )1;
      *((AT91_REG___0 *)4294964272U) = (AT91_REG___0 )pinmask;
      *((AT91_REG___0 *)4294964240U) = (AT91_REG___0 )pinmask;
      *((AT91_REG___0 *)4294964304U) = (AT91_REG___0 )p->scl_pin;
      *((AT91_REG___0 *)4294964320U) = (AT91_REG___0 )p->sda_pin;
      *((AT91_REG___0 *)4294964324U) = (AT91_REG___0 )p->scl_pin;
    }
  }
  return;
}
}
void i2c_init(void) 
{ 
  int istate ;
  U32___0 dummy ;
  int i ;
  struct i2c_port_struct *p ;

  {
  p = i2c_port;
  i = 0;
  while (i < 4) {
    p->state = (i2c_port_state )1;
    p->scl_pin = (U32___0 )i2c_pin[i].scl;
    p->sda_pin = (U32___0 )i2c_pin[i].sda;
    i2c_disable(i);
    p ++;
    i ++;
  }
  istate = interrupts_get_and_disable();
  *((AT91_REG___0 *)4294966288U) = (AT91_REG___0 )(1 << 12U);
  *((AT91_REG___0 *)4294574080U) = (AT91_REG___0 )2;
  *((AT91_REG___0 *)4294574120U) = (AT91_REG___0 )(~ 0);
  dummy = (U32___0 )*((AT91_REG___0 *)4294574112U);
  *((AT91_REG___0 *)4294574084U) = (AT91_REG___0 )16384;
  *((AT91_REG___0 *)4294574108U) = (AT91_REG___0 )625;
  *((AT91_REG___0 *)4294574116U) = (AT91_REG___0 )16;
  *((AT91_REG___0 *)4294574080U) = (AT91_REG___0 )1;
  aic_mask_off((U32___0 )12U);
  aic_set_vector((U32___0 )12U, (U32___0 )4, (U32___0 )(& i2c_timer_isr_entry));
  aic_mask_on((U32___0 )12U);
  *((AT91_REG___0 *)4294574080U) = (AT91_REG___0 )4;
  if (istate) {
    interrupts_enable();
  }
  return;
}
}
int i2c_busy(int port ) 
{ 


  {
  if (port >= 0) {
    if (port < 4) {
      return ((unsigned int )i2c_port[port].state > 1U);
    }
  }
  return (0);
}
}
int i2c_start_transaction(int port , U32___0 address , int internal_address , int n_internal_address_bytes ,
                          U8___0 *data , U32___0 nbytes , int write ) 
{ 
  struct i2c_port_struct *p ;
  struct i2c_partial_transaction *pt ;
  int tmp ;
  int tmp___0 ;

  {
  if (port < 0) {
    return (-1);
  } else
  if (port >= 4) {
    return (-1);
  }
  tmp = i2c_busy(port);
  if (tmp) {
    return (-1);
  }
  p = & i2c_port[port];
  p->pt_num = (U32___0 )0;
  p->pt_begun = (U32___0 )0;
  pt = p->partial_transaction;
  p->current_pt = pt;
  memset((void *)pt, 0, sizeof(p->partial_transaction));
  if (n_internal_address_bytes > 0) {
    p->addr_int[0] = (U8___0 )(address << 1);
    p->addr_int[1] = (U8___0 )internal_address;
    pt->start = (U8___0 )1;
    if (write) {
      pt->stop = (U8___0 )0;
    } else {
      pt->stop = (U8___0 )1;
    }
    pt->tx = (U8___0 )1;
    pt->data = p->addr_int;
    pt->nbytes = (U16___0 )2;
    pt ++;
  }
  if (n_internal_address_bytes == 0) {
    goto _L;
  } else
  if (! write) {
    _L: 
    if (n_internal_address_bytes > 0) {
      pt->start = (U8___0 )0;
    } else {
      pt->start = (U8___0 )1;
    }
    pt->restart = (U8___0 )(! pt->start);
    pt->stop = (U8___0 )0;
    pt->tx = (U8___0 )1;
    if (write) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    p->addr = (U8___0 )((address << 1) | (unsigned long )tmp___0);
    pt->data = & p->addr;
    pt->nbytes = (U16___0 )1;
    pt ++;
  }
  pt->start = (U8___0 )0;
  pt->stop = (U8___0 )1;
  if (write) {
    pt->tx = (U8___0 )1;
  } else {
    pt->tx = (U8___0 )0;
  }
  pt->data = data;
  pt->nbytes = (U16___0 )nbytes;
  pt->last_pt = (U8___0 )1;
  p->state = (i2c_port_state )2;
  return (0);
}
}
U8___1 ecrobot_get_button_state(void) ;
void ecrobot_init_nxtstate(void) ;
void ecrobot_poll_nxtstate(void) ;
void ecrobot_setDeviceInitialized(void) ;
void ecrobot_initDeviceStatus(void) ;
extern int twi_init(void) ;
extern void twi_start_write(unsigned long dev_addr , unsigned char const   *data ,
                            unsigned long nBytes ) ;
extern void twi_start_read(unsigned long dev_addr , unsigned char *data , unsigned long nBytes ) ;
extern int twi_status(void) ;
extern void set_digi0(int  ) ;
extern void unset_digi0(int  ) ;
extern void sound_freq_vol(U32___1 freq , U32___1 ms , int vol ) ;
extern void sound_play_sample(U8___1 *data , U32___1 length , U32___1 freq , int vol ) ;
extern int sound_get_time() ;
extern SINT ecrobot_get_bt_status(void) ;
extern U32___1 ecrobot_send_bt_packet(U8___1 *buf , U32___1 bufLen ) ;
S32___0 ecrobot_get_motor_rev(U8___1 port_id ) ;
void ecrobot_set_motor_speed(U8___1 port_id , S8___0 speed ) ;
void ecrobot_set_motor_mode_speed(U8___1 port_id , S32___0 mode___0 , S8___0 speed ) ;
U16___1 ecrobot_get_light_sensor(U32___1 port_id ) ;
void ecrobot_set_light_sensor_active(U32___1 port_id ) ;
void ecrobot_set_light_sensor_inactive(U32___1 port_id ) ;
U8___1 ecrobot_get_touch_sensor(U8___1 port_id ) ;
U16___1 ecrobot_get_sound_sensor(U8___1 port_id ) ;
void ecrobot_init_i2c(U8___1 port_id , U8___1 type ) ;
U8___1 ecrobot_wait_i2c_ready(U8___1 port_id , U32___1 wait ) ;
SINT ecrobot_send_i2c(U8___1 port_id , U32___1 address , SINT i2c_reg , U8___1 *buf ,
                      U32___1 len ) ;
SINT ecrobot_read_i2c(U8___1 port_id , U32___1 address , SINT i2c_reg , U8___1 *buf ,
                      U32___1 len ) ;
void ecrobot_term_i2c(U8___1 port_id ) ;
void ecrobot_init_sonar_sensor(U8___1 port_id ) ;
void ecrobot_term_sonar_sensor(U8___1 port_id ) ;
void ecrobot_init_nxtcolorsensor(U8___1 port_id , U8___1 mode___0 ) ;
void ecrobot_set_nxtcolorsensor(U8___1 port_id , U8___1 mode___0 ) ;
U8___1 ecrobot_get_nxtcolorsensor_mode(U8___1 port_id ) ;
U16___1 ecrobot_get_nxtcolorsensor_id(U8___1 port_id ) ;
void ecrobot_get_nxtcolorsensor_rgb(U8___1 port_id , S16___0 *rgb ) ;
void ecrobot_term_nxtcolorsensor(U8___1 port_id ) ;
void ecrobot_set_RCX_power_source(U8___1 port_id ) ;
void ecrobot_term_RCX_power_source(U8___1 port_id ) ;
S16___0 ecrobot_get_RCX_sensor(U8___1 port_id ) ;
U8___1 ecrobot_get_RCX_touch_sensor(U8___1 port_id ) ;
U16___1 ecrobot_get_battery_voltage(void) ;
U32___1 ecrobot_get_systick_ms(void) ;
U8___1 ecrobot_is_ENTER_button_pressed(void) ;
U8___1 ecrobot_is_RUN_button_pressed(void) ;
SINT ecrobot_bmp2lcd(CHAR const   *file , U8___1 *lcd , S32___0 width , S32___0 height ) ;
void ecrobot_show_int(S32___0 var ) ;
void ecrobot_debug1(UINT var1 , UINT var2 , UINT var3 ) ;
void ecrobot_debug2(UINT var1 , UINT var2 , UINT var3 ) ;
void ecrobot_status_monitor(CHAR const   *target_name ) ;
void ecrobot_adc_data_monitor(CHAR const   *target_name ) ;
void ecrobot_bt_data_logger(S8___0 data1 , S8___0 data2 ) ;
void ecrobot_bt_adc_data_logger(S8___0 data1 , S8___0 data2 , S16___0 adc1 , S16___0 adc2 ,
                                S16___0 adc3 , S16___0 adc4 ) ;
void ecrobot_sint_var_monitor(SINT *vars ) ;
SINT ecrobot_sound_tone(U32___1 freq , U32___1 ms , U32___1 vol ) ;
SINT ecrobot_sound_wav(CHAR const   *file , U32___1 length , S32___0 freq , U32___1 vol ) ;
extern void colorsensor_init(int  , unsigned char  ) ;
extern void colorsensor_term(int  ) ;
extern int colorsensor_light_get(int  ) ;
extern void colorsensor_light_full(int port ) ;
extern int colorsensor_color_get(int  ) ;
extern void colorsensor_rgb_get(int  , short * ) ;
static unsigned char volatile   deviceStatus  =    (U8___1 volatile   )2;
void ecrobot_set_motor_speed(U8___1 port_id , S8___0 speed ) 
{ 


  {
  nxt_motor_set_speed((U32___1 )port_id, (int )speed, 1);
  return;
}
}
void ecrobot_set_motor_mode_speed(U8___1 port_id , S32___0 mode___0 , S8___0 speed ) 
{ 


  {
  nxt_motor_set_speed((U32___1 )port_id, (int )speed, (int )mode___0);
  return;
}
}
S32___0 ecrobot_get_motor_rev(U8___1 port_id ) 
{ 
  int tmp ;

  {
  tmp = nxt_motor_get_count((U32___1 )port_id);
  return ((S32___0 )tmp);
}
}
void ecrobot_set_motor_rev(U8___1 port_id , S32___0 rev ) 
{ 


  {
  nxt_motor_set_count((U32___1 )port_id, (int )rev);
  return;
}
}
void ecrobot_set_light_sensor_active(U32___1 port_id ) 
{ 


  {
  set_digi0((int )port_id);
  return;
}
}
void ecrobot_set_light_sensor_inactive(U32___1 port_id ) 
{ 


  {
  unset_digi0((int )port_id);
  return;
}
}
U16___1 ecrobot_get_light_sensor(U32___1 port_id ) 
{ 
  U32___1 tmp ;

  {
  tmp = sensor_adc(port_id);
  return ((U16___1 )tmp);
}
}
U8___1 ecrobot_get_touch_sensor(U8___1 port_id ) 
{ 
  U32___1 tmp ;

  {
  tmp = sensor_adc((U32___1 )port_id);
  return ((U8___1 )(tmp < 512UL));
}
}
U16___1 ecrobot_get_sound_sensor(U8___1 port_id ) 
{ 
  U32___1 tmp ;

  {
  tmp = sensor_adc((U32___1 )port_id);
  return ((U16___1 )tmp);
}
}
void ecrobot_init_i2c(U8___1 port_id , U8___1 type ) 
{ 


  {
  if ((int volatile   )deviceStatus == (int volatile   )2) {
    nxt_avr_set_input_power((U32___1 )port_id, (U32___1 )type);
    i2c_enable((int )port_id);
  }
  return;
}
}
U8___1 ecrobot_wait_i2c_ready(U8___1 port_id , U32___1 wait ) 
{ 
  U32___1 volatile   time_out ;
  U32___1 tmp ;
  int tmp___0 ;
  U32___1 tmp___1 ;

  {
  tmp = systick_get_ms();
  time_out = (U32___1 volatile   )(tmp + wait);
  while (1) {
    tmp___1 = systick_get_ms();
    if (! (tmp___1 <= (U32___1 )time_out)) {
      break;
    }
    tmp___0 = i2c_busy((int )port_id);
    if (tmp___0 == 0) {
      return ((U8___1 )1);
    }
  }
  return ((U8___1 )0);
}
}
SINT ecrobot_send_i2c(U8___1 port_id , U32___1 address , SINT i2c_reg , U8___1 *buf ,
                      U32___1 len ) 
{ 
  SINT ret ;
  int port7 ;
  U32___0 address8 ;
  int internal_address9 ;
  int n_internal_address_bytes10 ;
  U8___0 *data11 ;
  U32___0 nbytes12 ;
  int write13 ;
  struct i2c_port_struct *p14 ;
  struct i2c_partial_transaction *pt15 ;
  int tmp16 ;
  int tmp___017 ;
  int ret_i2c_start_transaction18 ;

  {
  ecrobot_wait_i2c_ready(port_id, (U32___1 )50);
  port7 = (int )port_id;
  address8 = address;
  internal_address9 = i2c_reg;
  n_internal_address_bytes10 = 1;
  data11 = buf;
  nbytes12 = len;
  write13 = 1;
  if (port7 < 0) {
    ret_i2c_start_transaction18 = -1;
    goto Lret_i2c_start_transaction;
  } else
  if (port7 >= 4) {
    ret_i2c_start_transaction18 = -1;
    goto Lret_i2c_start_transaction;
  }
  tmp16 = i2c_busy(port7);
  if (tmp16) {
    ret_i2c_start_transaction18 = -1;
    goto Lret_i2c_start_transaction;
  }
  p14 = & i2c_port[port7];
  p14->pt_num = (U32___0 )0;
  p14->pt_begun = (U32___0 )0;
  pt15 = p14->partial_transaction;
  p14->current_pt = pt15;
  memset((void *)pt15, 0, sizeof(p14->partial_transaction));
  if (n_internal_address_bytes10 > 0) {
    p14->addr_int[0] = (U8___0 )(address8 << 1);
    p14->addr_int[1] = (U8___0 )internal_address9;
    pt15->start = (U8___0 )1;
    if (write13) {
      pt15->stop = (U8___0 )0;
    } else {
      pt15->stop = (U8___0 )1;
    }
    pt15->tx = (U8___0 )1;
    pt15->data = p14->addr_int;
    pt15->nbytes = (U16___0 )2;
    pt15 ++;
  }
  if (n_internal_address_bytes10 == 0) {
    goto _L;
  } else
  if (! write13) {
    _L: 
    if (n_internal_address_bytes10 > 0) {
      pt15->start = (U8___0 )0;
    } else {
      pt15->start = (U8___0 )1;
    }
    pt15->restart = (U8___0 )(! pt15->start);
    pt15->stop = (U8___0 )0;
    pt15->tx = (U8___0 )1;
    if (write13) {
      tmp___017 = 0;
    } else {
      tmp___017 = 1;
    }
    p14->addr = (U8___0 )((address8 << 1) | (unsigned long )tmp___017);
    pt15->data = & p14->addr;
    pt15->nbytes = (U16___0 )1;
    pt15 ++;
  }
  pt15->start = (U8___0 )0;
  pt15->stop = (U8___0 )1;
  if (write13) {
    pt15->tx = (U8___0 )1;
  } else {
    pt15->tx = (U8___0 )0;
  }
  pt15->data = data11;
  pt15->nbytes = (U16___0 )nbytes12;
  pt15->last_pt = (U8___0 )1;
  p14->state = (i2c_port_state )2;
  ret_i2c_start_transaction18 = 0;
  goto Lret_i2c_start_transaction;
  Lret_i2c_start_transaction: 
  ret = ret_i2c_start_transaction18;
  return (! ret);
}
}
SINT ecrobot_read_i2c(U8___1 port_id , U32___1 address , SINT i2c_reg , U8___1 *buf ,
                      U32___1 len ) 
{ 
  SINT ret ;
  int port7 ;
  U32___0 address8 ;
  int internal_address9 ;
  int n_internal_address_bytes10 ;
  U8___0 *data11 ;
  U32___0 nbytes12 ;
  int write13 ;
  struct i2c_port_struct *p14 ;
  struct i2c_partial_transaction *pt15 ;
  int tmp16 ;
  int tmp___017 ;
  int ret_i2c_start_transaction18 ;

  {
  ecrobot_wait_i2c_ready(port_id, (U32___1 )50);
  port7 = (int )port_id;
  address8 = address;
  internal_address9 = i2c_reg;
  n_internal_address_bytes10 = 1;
  data11 = buf;
  nbytes12 = len;
  write13 = 0;
  if (port7 < 0) {
    ret_i2c_start_transaction18 = -1;
    goto Lret_i2c_start_transaction;
  } else
  if (port7 >= 4) {
    ret_i2c_start_transaction18 = -1;
    goto Lret_i2c_start_transaction;
  }
  tmp16 = i2c_busy(port7);
  if (tmp16) {
    ret_i2c_start_transaction18 = -1;
    goto Lret_i2c_start_transaction;
  }
  p14 = & i2c_port[port7];
  p14->pt_num = (U32___0 )0;
  p14->pt_begun = (U32___0 )0;
  pt15 = p14->partial_transaction;
  p14->current_pt = pt15;
  memset((void *)pt15, 0, sizeof(p14->partial_transaction));
  if (n_internal_address_bytes10 > 0) {
    p14->addr_int[0] = (U8___0 )(address8 << 1);
    p14->addr_int[1] = (U8___0 )internal_address9;
    pt15->start = (U8___0 )1;
    if (write13) {
      pt15->stop = (U8___0 )0;
    } else {
      pt15->stop = (U8___0 )1;
    }
    pt15->tx = (U8___0 )1;
    pt15->data = p14->addr_int;
    pt15->nbytes = (U16___0 )2;
    pt15 ++;
  }
  if (n_internal_address_bytes10 == 0) {
    goto _L;
  } else
  if (! write13) {
    _L: 
    if (n_internal_address_bytes10 > 0) {
      pt15->start = (U8___0 )0;
    } else {
      pt15->start = (U8___0 )1;
    }
    pt15->restart = (U8___0 )(! pt15->start);
    pt15->stop = (U8___0 )0;
    pt15->tx = (U8___0 )1;
    if (write13) {
      tmp___017 = 0;
    } else {
      tmp___017 = 1;
    }
    p14->addr = (U8___0 )((address8 << 1) | (unsigned long )tmp___017);
    pt15->data = & p14->addr;
    pt15->nbytes = (U16___0 )1;
    pt15 ++;
  }
  pt15->start = (U8___0 )0;
  pt15->stop = (U8___0 )1;
  if (write13) {
    pt15->tx = (U8___0 )1;
  } else {
    pt15->tx = (U8___0 )0;
  }
  pt15->data = data11;
  pt15->nbytes = (U16___0 )nbytes12;
  pt15->last_pt = (U8___0 )1;
  p14->state = (i2c_port_state )2;
  ret_i2c_start_transaction18 = 0;
  goto Lret_i2c_start_transaction;
  Lret_i2c_start_transaction: 
  ret = ret_i2c_start_transaction18;
  return (! ret);
}
}
void ecrobot_term_i2c(U8___1 port_id ) 
{ 


  {
  i2c_disable((int )port_id);
  return;
}
}*/
static S32___0 distance_state[4]  = {      (S32___0 )-1,      (S32___0 )-1,      (S32___0 )-1,      (S32___0 )-1};
/*
static S32___0 getDistance(void) 
{ 
  SINT i ;

  {
  i = 0;
  while (i < 4) {
    if (distance_state[i] != -1L) {
      return (distance_state[i]);
    }
    i ++;
  }
  return ((S32___0 )-1);
}
}
void ecrobot_init_sonar_sensor(U8___1 port_id ) 
{ 


  {
  ecrobot_init_i2c(port_id, (U8___1 )2);
  return;
}
}
static U8___1 data[4]  = {      (U8___1 )0};
void ecrobot_term_sonar_sensor(U8___1 port_id ) 
{ 


  {
  distance_state[0] = (S32___0 )-1;
  distance_state[1] = (S32___0 )-1;
  distance_state[2] = (S32___0 )-1;
  distance_state[3] = (S32___0 )-1;
  i2c_disable((int )port_id);
  return;
}
}*/
U8___1 const   NXT_COLORSENSOR_PROTOCOLS[7]  = {      (U8___1 const   )176,      (U8___1 const   )112,      (U8___1 const   )240,      (U8___1 const   )8, 
        (U8___1 const   )176,      (U8___1 const   )136,      (U8___1 const   )136};

static NXTCOLORSENSOR_T sensor_data[4]  ;
/*
void ecrobot_init_nxtcolorsensor(U8___1 port_id , U8___1 mode___0 ) 
{ 


  {
  if ((int volatile   )deviceStatus == (int volatile   )2) {
    ecrobot_set_nxtcolorsensor(port_id, (U8___1 )6);
    ecrobot_set_nxtcolorsensor(port_id, mode___0);
  }
  return;
}
}
void ecrobot_set_nxtcolorsensor(U8___1 port_id , U8___1 mode___0 ) 
{ 


  {
  if ((int )mode___0 == 6) {
    sensor_data[port_id].color = (U16___1 )99;
    sensor_data[port_id].rgb[0] = (S16___0 )0;
    sensor_data[port_id].rgb[1] = (S16___0 )0;
    sensor_data[port_id].rgb[2] = (S16___0 )0;
    sensor_data[port_id].light = (U16___1 )0;
    sensor_data[port_id].mode_state = (U8___1 volatile   )mode___0;
  }
  sensor_data[port_id].mode = (U8___1 volatile   )mode___0;
  sensor_data[port_id].port_in_use = (U8___1 volatile   )1;
  return;
}
}
U8___1 ecrobot_get_nxtcolorsensor_mode(U8___1 port_id ) 
{ 


  {
  return ((U8___1 )sensor_data[port_id].mode);
}
}
U16___1 ecrobot_get_nxtcolorsensor_id(U8___1 port_id ) 
{ 
  U16___1 color ;

  {
  color = (U16___1 )99;
  switch ((int )sensor_data[port_id].color) {
  case 0: 
  color = (U16___1 )0;
  break;
  case 1: 
  case 2: 
  color = (U16___1 )1;
  break;
  case 3: 
  color = (U16___1 )2;
  break;
  case 4: 
  color = (U16___1 )3;
  break;
  case 5: 
  color = (U16___1 )4;
  break;
  case 6: 
  color = (U16___1 )5;
  break;
  case 7: 
  color = (U16___1 )6;
  break;
  default: 
  break;
  }
  return (color);
}
}
void ecrobot_get_nxtcolorsensor_rgb(U8___1 port_id , S16___0 *rgb ) 
{ 


  {
  *(rgb + 0) = sensor_data[port_id].rgb[0];
  *(rgb + 1) = sensor_data[port_id].rgb[1];
  *(rgb + 2) = sensor_data[port_id].rgb[2];
  return;
}
}
void ecrobot_term_nxtcolorsensor(U8___1 port_id ) 
{ 


  {
  colorsensor_term((int )port_id);
  return;
}
}
void ecrobot_set_RCX_power_source(U8___1 port_id ) 
{ 


  {
  if ((int volatile   )deviceStatus == (int volatile   )2) {
    nxt_avr_set_input_power((U32___1 )port_id, (U32___1 )1);
  }
  return;
}
}
void ecrobot_term_RCX_power_source(U8___1 port_id ) 
{ 


  {
  nxt_avr_set_input_power((U32___1 )port_id, (U32___1 )0);
  return;
}
}
S16___0 ecrobot_get_RCX_sensor(U8___1 port_id ) 
{ 
  U32___1 tmp ;

  {
  tmp = sensor_adc((U32___1 )port_id);
  return ((S16___0 )tmp);
}
}
U8___1 ecrobot_get_RCX_touch_sensor(U8___1 port_id ) 
{ 
  U32___1 tmp ;

  {
  tmp = sensor_adc((U32___1 )port_id);
  return ((U8___1 )(tmp < 512UL));
}
}
static nxt_inputs ecrobot_inputs  ;
static U8___1 buttons_states[20]  ;
static SINT buttons_i  ;
U16___1 ecrobot_get_battery_voltage(void) 
{ 


  {
  return ((U16___1 )ecrobot_inputs.battery_state);
}
}
U32___1 ecrobot_get_systick_ms(void) 
{ 
  U32___1 tmp ;

  {
  tmp = systick_get_ms();
  return (tmp);
}
}
U8___1 ecrobot_is_ENTER_button_pressed(void) 
{ 
  U8___1 tmp ;

  {
  tmp = ecrobot_get_button_state();
  return ((U8___1 )(((int )tmp & 1) == 1));
}
}
U8___1 ecrobot_is_RUN_button_pressed(void) 
{ 
  U8___1 tmp ;

  {
  tmp = ecrobot_get_button_state();
  return ((U8___1 )(((int )tmp & 4) == 4));
}
}
void ecrobot_init_nxtstate(void) 
{ 


  {
  ecrobot_inputs.buttons_state = (U8___1 )0;
  memset((void *)(buttons_states), 0, sizeof(buttons_states));
  buttons_i = 0;
  return;
}
}
U8___1 ecrobot_get_button_state(void) 
{ 


  {
  return (ecrobot_inputs.buttons_state);
}
}
void ecrobot_poll_nxtstate(void) 
{ 
  SINT i ;
  SINT tmp ;
  U32___1 tmp___0 ;

  {
  ecrobot_inputs.battery_state = battery_voltage();
  tmp = buttons_i;
  buttons_i ++;
  tmp___0 = buttons_get();
  buttons_states[tmp] = (U8___1 )((int )((U8___1 )tmp___0) & 15);
  if (buttons_i == 20) {
    buttons_i = 0;
  }
  i = 1;
  while (i < 20) {
    if ((int )buttons_states[i - 1] != (int )buttons_states[i]) {
      return;
    }
    if (i == 19) {
      ecrobot_inputs.buttons_state = buttons_states[i];
    }
    i ++;
  }
  return;
}
}
void ecrobot_setDeviceInitialized(void) 
{ 


  {
  if ((int volatile   )deviceStatus == (int volatile   )2) {
    deviceStatus = (unsigned char volatile   )3;
  }
  return;
}
}
void ecrobot_initDeviceStatus(void) 
{ 


  {
  deviceStatus = (unsigned char volatile   )2;
  return;
}
}
U8___1 get_device_status(void) 
{ 


  {
  return ((U8___1 )deviceStatus);
}
}
extern int restart_NXT() ;
void ecrobot_restart_NXT(void) 
{ 


  {
  restart_NXT();
  return;
}
}
extern int shutdown_NXT() ;
void ecrobot_shutdown_NXT(void) 
{ 


  {
  shutdown_NXT();
  return;
}
}
extern int exec_NXT_BIOS() ;
void ecrobot_exec_NXT_BIOS(void) 
{ 


  {
  exec_NXT_BIOS();
  return;
}
}
static S16___0 adc[4]  ;
void ecrobot_bt_data_logger(S8___0 data1 , S8___0 data2 ) 
{ 
  U8___1 data_log_buffer[32] ;
  U32___1 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  U32___1 tmp___3 ;
  U32___1 tmp___4 ;
  U32___1 tmp___5 ;
  U32___1 tmp___6 ;
  S32___0 tmp___7 ;

  {
  tmp = systick_get_ms();
  *((U32___1 *)(& data_log_buffer[0])) = tmp;
  *((S8___0 *)(& data_log_buffer[4])) = data1;
  *((S8___0 *)(& data_log_buffer[5])) = data2;
  *((U16___1 *)(& data_log_buffer[6])) = (U16___1 )ecrobot_inputs.battery_state;
  tmp___0 = nxt_motor_get_count((U32___1 )0);
  *((S32___0 *)(& data_log_buffer[8])) = (S32___0 )tmp___0;
  tmp___1 = nxt_motor_get_count((U32___1 )1);
  *((S32___0 *)(& data_log_buffer[12])) = (S32___0 )tmp___1;
  tmp___2 = nxt_motor_get_count((U32___1 )2);
  *((S32___0 *)(& data_log_buffer[16])) = (S32___0 )tmp___2;
  tmp___3 = sensor_adc((U32___1 )0);
  *((S16___0 *)(& data_log_buffer[20])) = (S16___0 )tmp___3;
  tmp___4 = sensor_adc((U32___1 )1);
  *((S16___0 *)(& data_log_buffer[22])) = (S16___0 )tmp___4;
  tmp___5 = sensor_adc((U32___1 )2);
  *((S16___0 *)(& data_log_buffer[24])) = (S16___0 )tmp___5;
  tmp___6 = sensor_adc((U32___1 )3);
  *((S16___0 *)(& data_log_buffer[26])) = (S16___0 )tmp___6;
  tmp___7 = getDistance();
  *((S32___0 *)(& data_log_buffer[28])) = tmp___7;
  ecrobot_send_bt_packet(data_log_buffer, (U32___1 )32);
  return;
}
}
void ecrobot_bt_adc_data_logger(S8___0 data1 , S8___0 data2 , S16___0 adc1 , S16___0 adc2 ,
                                S16___0 adc3 , S16___0 adc4 ) 
{ 
  U8___1 data_log_buffer[32] ;
  U32___1 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  S32___0 tmp___3 ;

  {
  tmp = systick_get_ms();
  *((U32___1 *)(& data_log_buffer[0])) = tmp;
  *((S8___0 *)(& data_log_buffer[4])) = data1;
  *((S8___0 *)(& data_log_buffer[5])) = data2;
  *((U16___1 *)(& data_log_buffer[6])) = (U16___1 )ecrobot_inputs.battery_state;
  tmp___0 = nxt_motor_get_count((U32___1 )0);
  *((S32___0 *)(& data_log_buffer[8])) = (S32___0 )tmp___0;
  tmp___1 = nxt_motor_get_count((U32___1 )1);
  *((S32___0 *)(& data_log_buffer[12])) = (S32___0 )tmp___1;
  tmp___2 = nxt_motor_get_count((U32___1 )2);
  *((S32___0 *)(& data_log_buffer[16])) = (S32___0 )tmp___2;
  *((S16___0 *)(& data_log_buffer[20])) = adc1;
  *((S16___0 *)(& data_log_buffer[22])) = adc2;
  *((S16___0 *)(& data_log_buffer[24])) = adc3;
  *((S16___0 *)(& data_log_buffer[26])) = adc4;
  tmp___3 = getDistance();
  *((S32___0 *)(& data_log_buffer[28])) = tmp___3;
  adc[0] = adc1;
  adc[1] = adc2;
  adc[2] = adc3;
  adc[3] = adc4;
  ecrobot_send_bt_packet(data_log_buffer, (U32___1 )32);
  return;
}
}
SINT ecrobot_bmp2lcd(CHAR const   *file , U8___1 *lcd , S32___0 width , S32___0 height ) 
{ 
  SINT bmp_line ;
  SINT bmp_line_alignment ;
  SINT bmp_row ;
  SINT bmp_col ;
  SINT lcd_row ;
  SINT lcd_pos ;
  SINT bmp_bit_pos ;
  SINT lcd_bit_pos ;
  SINT bits ;
  U8___1 bmp_data ;
  BMP *bmp ;
  int lcd_index ;

  {
  bmp = (BMP *)file;
  if ((int )bmp->fileHeader.type != 19778) {
    return (-1);
  }
  if (bmp->infoHeader.width > 100L) {
    return (-1);
  } else
  if (bmp->infoHeader.width < 1L) {
    return (-1);
  } else
  if (bmp->infoHeader.width != width) {
    return (-1);
  }
  if (bmp->infoHeader.height > 64L) {
    return (-1);
  } else
  if (bmp->infoHeader.height < 1L) {
    return (-1);
  } else
  if (bmp->infoHeader.height != height) {
    return (-1);
  }
  if ((int )bmp->infoHeader.bits != 1) {
    return (-1);
  }
  if (bmp->infoHeader.compression != 0UL) {
    return (-1);
  }
  bmp_line = (SINT )(bmp->infoHeader.width / 8L);
  if (bmp->infoHeader.width % 8L) {
    bmp_line ++;
  }
  if (bmp_line % 4 != 0) {
    bmp_line_alignment = (bmp_line / 4 + 1) * 4;
  } else {
    bmp_line_alignment = bmp_line;
  }
  bmp_row = 0;
  while ((S32___0 )bmp_row < bmp->infoHeader.height) {
    lcd_row = 8 - (bmp_row / 8 + 1);
    lcd_bit_pos = bmp_row % 8;
    bits = 0;
    bmp_col = 0;
    while (bmp_col < bmp_line) {
      bmp_data = (U8___1 )*(file + ((U32___1 )(bmp_row * bmp_line_alignment + bmp_col) + bmp->fileHeader.offset));
      lcd_pos = lcd_row * 100 + bmp_col * 8;
      bmp_bit_pos = 0;
      while (1) {
        if (bmp_bit_pos < 8) {
          if (! ((S32___0 )bits < bmp->infoHeader.width)) {
            break;
          }
        } else {
          break;
        }
        lcd_index = lcd_pos + bmp_bit_pos;
        if (lcd_index < 800) {
          if (! ((int )bmp_data & (1 << (7 - bmp_bit_pos)))) {
            *(lcd + lcd_index) = (U8___1 )((int )*(lcd + lcd_index) | (128 >> lcd_bit_pos));
          } else {
            *(lcd + lcd_index) = (U8___1 )((int )*(lcd + lcd_index) & (-129 >> lcd_bit_pos));
          }
        }
        bmp_bit_pos ++;
        bits ++;
      }
      bmp_col ++;
    }
    bmp_row ++;
  }
  return (1);
}
}
void ecrobot_show_int(S32___0 var ) 
{ 
  int x2 ;
  int y3 ;
  char const   *str4 ;
  int val5 ;
  U32 places6 ;
  int tmp7 ;

  {
  display_clear((U32___1 )0);
  x2 = 0;
  y3 = 7;
  display_x = x2;
  display_y = y3;
  goto Lret_display_goto_xy;
  Lret_display_goto_xy: 
  str4 = "VAR: ";
  while (*str4) {
    if ((int const   )*str4 != 10) {
      display_char((int )*str4);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str4 ++;
  }
  goto Lret_display_string;
  Lret_display_string: 
  {
  val5 = (int )var;
  places6 = (U32___1 )0;
  {
  if (val5 < 0) {
    tmp7 = - val5;
  } else {
    tmp7 = val5;
  }
  display_unsigned_worker((U32 )tmp7, places6, (U32 )(val5 < 0));
  goto Lret_display_int;
  }
  Lret_display_int:  ;
  display_update();
  }
  return;
}
}
void ecrobot_debug(UINT var ) 
{ 
  int x2 ;
  int y3 ;
  char const   *str4 ;
  int val5 ;
  U32 places6 ;
  int tmp7 ;

  {
  display_clear((U32___1 )0);
  x2 = 0;
  y3 = 7;
  display_x = x2;
  display_y = y3;
  goto Lret_display_goto_xy;
  Lret_display_goto_xy: 
  str4 = "DBG: ";
  while (*str4) {
    if ((int const   )*str4 != 10) {
      display_char((int )*str4);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str4 ++;
  }
  goto Lret_display_string;
  Lret_display_string: 
  {
  val5 = (int )var;
  places6 = (U32___1 )0;
  {
  if (val5 < 0) {
    tmp7 = - val5;
  } else {
    tmp7 = val5;
  }
  display_unsigned_worker((U32 )tmp7, places6, (U32 )(val5 < 0));
  goto Lret_display_int;
  }
  Lret_display_int:  ;
  display_update();
  }
  return;
}
}
void ecrobot_debug1(UINT var1 , UINT var2 , UINT var3 ) 
{ 
  int x4 ;
  int y5 ;
  int x6 ;
  int y7 ;
  int x8 ;
  int y9 ;
  char const   *str10 ;
  char const   *str11 ;
  char const   *str12 ;
  int val13 ;
  U32 places14 ;
  int tmp15 ;
  int val16 ;
  U32 places17 ;
  int tmp18 ;
  int val19 ;
  U32 places20 ;
  int tmp21 ;

  {
  display_clear((U32___1 )0);
  x4 = 0;
  y5 = 1;
  display_x = x4;
  display_y = y5;
  goto Lret_display_goto_xy;
  Lret_display_goto_xy: 
  str10 = "VAR1: ";
  while (*str10) {
    if ((int const   )*str10 != 10) {
      display_char((int )*str10);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str10 ++;
  }
  goto Lret_display_string;
  Lret_display_string: 
  {
  val13 = (int )var1;
  places14 = (U32___1 )0;
  {
  if (val13 < 0) {
    tmp15 = - val13;
  } else {
    tmp15 = val13;
  }
  display_unsigned_worker((U32 )tmp15, places14, (U32 )(val13 < 0));
  goto Lret_display_int;
  }
  Lret_display_int:  ;
  x6 = 0;
  y7 = 2;
  display_x = x6;
  display_y = y7;
  }
  goto Lret_display_goto_xy___0;
  Lret_display_goto_xy___0: 
  str11 = "VAR2: ";
  while (*str11) {
    if ((int const   )*str11 != 10) {
      display_char((int )*str11);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str11 ++;
  }
  goto Lret_display_string___0;
  Lret_display_string___0: 
  {
  val16 = (int )var2;
  places17 = (U32___1 )0;
  {
  if (val16 < 0) {
    tmp18 = - val16;
  } else {
    tmp18 = val16;
  }
  display_unsigned_worker((U32 )tmp18, places17, (U32 )(val16 < 0));
  goto Lret_display_int___0;
  }
  Lret_display_int___0:  ;
  x8 = 0;
  y9 = 3;
  display_x = x8;
  display_y = y9;
  }
  goto Lret_display_goto_xy___1;
  Lret_display_goto_xy___1: 
  str12 = "VAR3: ";
  while (*str12) {
    if ((int const   )*str12 != 10) {
      display_char((int )*str12);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str12 ++;
  }
  goto Lret_display_string___1;
  Lret_display_string___1: 
  {
  val19 = (int )var3;
  places20 = (U32___1 )0;
  {
  if (val19 < 0) {
    tmp21 = - val19;
  } else {
    tmp21 = val19;
  }
  display_unsigned_worker((U32 )tmp21, places20, (U32 )(val19 < 0));
  goto Lret_display_int___1;
  }
  Lret_display_int___1:  ;
  display_update();
  }
  return;
}
}
void ecrobot_debug2(UINT var1 , UINT var2 , UINT var3 ) 
{ 
  int x4 ;
  int y5 ;
  int x6 ;
  int y7 ;
  int x8 ;
  int y9 ;
  char const   *str10 ;
  char const   *str11 ;
  char const   *str12 ;
  int val13 ;
  U32 places14 ;
  int tmp15 ;
  int val16 ;
  U32 places17 ;
  int tmp18 ;
  int val19 ;
  U32 places20 ;
  int tmp21 ;

  {
  display_clear((U32___1 )0);
  x4 = 0;
  y5 = 4;
  display_x = x4;
  display_y = y5;
  goto Lret_display_goto_xy;
  Lret_display_goto_xy: 
  str10 = "VAR4: ";
  while (*str10) {
    if ((int const   )*str10 != 10) {
      display_char((int )*str10);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str10 ++;
  }
  goto Lret_display_string;
  Lret_display_string: 
  {
  val13 = (int )var1;
  places14 = (U32___1 )0;
  {
  if (val13 < 0) {
    tmp15 = - val13;
  } else {
    tmp15 = val13;
  }
  display_unsigned_worker((U32 )tmp15, places14, (U32 )(val13 < 0));
  goto Lret_display_int;
  }
  Lret_display_int:  ;
  x6 = 0;
  y7 = 5;
  display_x = x6;
  display_y = y7;
  }
  goto Lret_display_goto_xy___0;
  Lret_display_goto_xy___0: 
  str11 = "VAR5: ";
  while (*str11) {
    if ((int const   )*str11 != 10) {
      display_char((int )*str11);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str11 ++;
  }
  goto Lret_display_string___0;
  Lret_display_string___0: 
  {
  val16 = (int )var2;
  places17 = (U32___1 )0;
  {
  if (val16 < 0) {
    tmp18 = - val16;
  } else {
    tmp18 = val16;
  }
  display_unsigned_worker((U32 )tmp18, places17, (U32 )(val16 < 0));
  goto Lret_display_int___0;
  }
  Lret_display_int___0:  ;
  x8 = 0;
  y9 = 6;
  display_x = x8;
  display_y = y9;
  }
  goto Lret_display_goto_xy___1;
  Lret_display_goto_xy___1: 
  str12 = "VAR6: ";
  while (*str12) {
    if ((int const   )*str12 != 10) {
      display_char((int )*str12);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str12 ++;
  }
  goto Lret_display_string___1;
  Lret_display_string___1: 
  {
  val19 = (int )var3;
  places20 = (U32___1 )0;
  {
  if (val19 < 0) {
    tmp21 = - val19;
  } else {
    tmp21 = val19;
  }
  display_unsigned_worker((U32 )tmp21, places20, (U32 )(val19 < 0));
  goto Lret_display_int___1;
  }
  Lret_display_int___1:  ;
  display_update();
  }
  return;
}
}
void ecrobot_status_monitor(CHAR const   *target_name ) 
{ 
  U32___1 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  U32___1 tmp___3 ;
  U32___1 tmp___4 ;
  U32___1 tmp___5 ;
  U32___1 tmp___6 ;
  SINT tmp___7 ;
  S32___0 tmp___8 ;
  int x12 ;
  int y13 ;
  int x14 ;
  int y15 ;
  int x16 ;
  int y17 ;
  int x18 ;
  int y19 ;
  int x20 ;
  int y21 ;
  int x22 ;
  int y23 ;
  int x24 ;
  int y25 ;
  int x26 ;
  int y27 ;
  char const   *str28 ;
  char const   *str29 ;
  char const   *str30 ;
  char const   *str31 ;
  char const   *str32 ;
  char const   *str33 ;
  char const   *str34 ;
  char const   *str35 ;
  int val36 ;
  U32 places37 ;
  int tmp38 ;
  int val39 ;
  U32 places40 ;
  int tmp41 ;
  int val42 ;
  U32 places43 ;
  int tmp44 ;
  int val45 ;
  U32 places46 ;
  int tmp47 ;

  {
  display_clear((U32___1 )0);
  x12 = 0;
  y13 = 0;
  display_x = x12;
  display_y = y13;
  goto Lret_display_goto_xy;
  Lret_display_goto_xy: 
  str28 = target_name;
  while (*str28) {
    if ((int const   )*str28 != 10) {
      display_char((int )*str28);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str28 ++;
  }
  goto Lret_display_string;
  Lret_display_string: 
  x14 = 0;
  y15 = 1;
  display_x = x14;
  display_y = y15;
  goto Lret_display_goto_xy___0;
  Lret_display_goto_xy___0: 
  str29 = "TIME:";
  while (*str29) {
    if ((int const   )*str29 != 10) {
      display_char((int )*str29);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str29 ++;
  }
  goto Lret_display_string___0;
  Lret_display_string___0: 
  tmp = systick_get_ms();
  display_unsigned(tmp / 1000UL, (U32___1 )0);
  x16 = 0;
  y17 = 2;
  display_x = x16;
  display_y = y17;
  goto Lret_display_goto_xy___1;
  Lret_display_goto_xy___1: 
  str30 = "BATT:";
  while (*str30) {
    if ((int const   )*str30 != 10) {
      display_char((int )*str30);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str30 ++;
  }
  goto Lret_display_string___1;
  Lret_display_string___1: 
  display_unsigned(ecrobot_inputs.battery_state / 100UL, (U32___1 )0);
  x18 = 0;
  y19 = 3;
  display_x = x18;
  display_y = y19;
  goto Lret_display_goto_xy___2;
  Lret_display_goto_xy___2: 
  str31 = "REV: ";
  while (*str31) {
    if ((int const   )*str31 != 10) {
      display_char((int )*str31);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str31 ++;
  }
  goto Lret_display_string___2;
  Lret_display_string___2: 
  {
  tmp___0 = nxt_motor_get_count((U32___1 )0);
  val36 = tmp___0;
  places37 = (U32___1 )0;
  {
  if (val36 < 0) {
    tmp38 = - val36;
  } else {
    tmp38 = val36;
  }
  display_unsigned_worker((U32 )tmp38, places37, (U32 )(val36 < 0));
  goto Lret_display_int;
  }
  Lret_display_int:  ;
  tmp___1 = nxt_motor_get_count((U32___1 )1);
  val39 = tmp___1;
  places40 = (U32___1 )6;
  {
  if (val39 < 0) {
    tmp41 = - val39;
  } else {
    tmp41 = val39;
  }
  display_unsigned_worker((U32 )tmp41, places40, (U32 )(val39 < 0));
  goto Lret_display_int___0;
  }
  Lret_display_int___0:  ;
  x20 = 0;
  y21 = 4;
  display_x = x20;
  display_y = y21;
  }
  goto Lret_display_goto_xy___3;
  Lret_display_goto_xy___3: 
  str32 = "     ";
  while (*str32) {
    if ((int const   )*str32 != 10) {
      display_char((int )*str32);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str32 ++;
  }
  goto Lret_display_string___3;
  Lret_display_string___3: 
  {
  tmp___2 = nxt_motor_get_count((U32___1 )2);
  val42 = tmp___2;
  places43 = (U32___1 )0;
  {
  if (val42 < 0) {
    tmp44 = - val42;
  } else {
    tmp44 = val42;
  }
  display_unsigned_worker((U32 )tmp44, places43, (U32 )(val42 < 0));
  goto Lret_display_int___1;
  }
  Lret_display_int___1:  ;
  x22 = 0;
  y23 = 5;
  display_x = x22;
  display_y = y23;
  }
  goto Lret_display_goto_xy___4;
  Lret_display_goto_xy___4: 
  str33 = "ADC: ";
  while (*str33) {
    if ((int const   )*str33 != 10) {
      display_char((int )*str33);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str33 ++;
  }
  goto Lret_display_string___4;
  Lret_display_string___4: 
  tmp___3 = sensor_adc((U32___1 )0);
  display_unsigned(tmp___3, (U32___1 )0);
  tmp___4 = sensor_adc((U32___1 )1);
  display_unsigned(tmp___4, (U32___1 )5);
  x24 = 0;
  y25 = 6;
  display_x = x24;
  display_y = y25;
  goto Lret_display_goto_xy___5;
  Lret_display_goto_xy___5: 
  str34 = "     ";
  while (*str34) {
    if ((int const   )*str34 != 10) {
      display_char((int )*str34);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str34 ++;
  }
  goto Lret_display_string___5;
  Lret_display_string___5: 
  tmp___5 = sensor_adc((U32___1 )2);
  display_unsigned(tmp___5, (U32___1 )0);
  tmp___6 = sensor_adc((U32___1 )3);
  display_unsigned(tmp___6, (U32___1 )5);
  x26 = 0;
  y27 = 7;
  display_x = x26;
  display_y = y27;
  goto Lret_display_goto_xy___6;
  Lret_display_goto_xy___6: 
  str35 = "BT/DST: ";
  while (*str35) {
    if ((int const   )*str35 != 10) {
      display_char((int )*str35);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str35 ++;
  }
  goto Lret_display_string___6;
  Lret_display_string___6: 
  tmp___7 = ecrobot_get_bt_status();
  if (tmp___7 == 7) {
    display_unsigned((U32___1 )1, (U32___1 )0);
  } else {
    display_unsigned((U32___1 )0, (U32___1 )0);
  }
  {
  tmp___8 = getDistance();
  val45 = (int )tmp___8;
  places46 = (U32___1 )5;
  {
  if (val45 < 0) {
    tmp47 = - val45;
  } else {
    tmp47 = val45;
  }
  display_unsigned_worker((U32 )tmp47, places46, (U32 )(val45 < 0));
  goto Lret_display_int___2;
  }
  Lret_display_int___2:  ;
  display_update();
  }
  return;
}
}
void ecrobot_adc_data_monitor(CHAR const   *target_name ) 
{ 
  U32___1 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  SINT tmp___3 ;
  S32___0 tmp___4 ;
  int x8 ;
  int y9 ;
  int x10 ;
  int y11 ;
  int x12 ;
  int y13 ;
  int x14 ;
  int y15 ;
  int x16 ;
  int y17 ;
  int x18 ;
  int y19 ;
  int x20 ;
  int y21 ;
  int x22 ;
  int y23 ;
  char const   *str24 ;
  char const   *str25 ;
  char const   *str26 ;
  char const   *str27 ;
  char const   *str28 ;
  char const   *str29 ;
  char const   *str30 ;
  char const   *str31 ;
  int val32 ;
  U32 places33 ;
  int tmp34 ;
  int val35 ;
  U32 places36 ;
  int tmp37 ;
  int val38 ;
  U32 places39 ;
  int tmp40 ;
  int val41 ;
  U32 places42 ;
  int tmp43 ;
  int val44 ;
  U32 places45 ;
  int tmp46 ;
  int val47 ;
  U32 places48 ;
  int tmp49 ;
  int val50 ;
  U32 places51 ;
  int tmp52 ;
  int val53 ;
  U32 places54 ;
  int tmp55 ;

  {
  display_clear((U32___1 )0);
  x8 = 0;
  y9 = 0;
  display_x = x8;
  display_y = y9;
  goto Lret_display_goto_xy;
  Lret_display_goto_xy: 
  str24 = target_name;
  while (*str24) {
    if ((int const   )*str24 != 10) {
      display_char((int )*str24);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str24 ++;
  }
  goto Lret_display_string;
  Lret_display_string: 
  x10 = 0;
  y11 = 1;
  display_x = x10;
  display_y = y11;
  goto Lret_display_goto_xy___0;
  Lret_display_goto_xy___0: 
  str25 = "TIME:";
  while (*str25) {
    if ((int const   )*str25 != 10) {
      display_char((int )*str25);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str25 ++;
  }
  goto Lret_display_string___0;
  Lret_display_string___0: 
  tmp = systick_get_ms();
  display_unsigned(tmp / 1000UL, (U32___1 )0);
  x12 = 0;
  y13 = 2;
  display_x = x12;
  display_y = y13;
  goto Lret_display_goto_xy___1;
  Lret_display_goto_xy___1: 
  str26 = "BATT:";
  while (*str26) {
    if ((int const   )*str26 != 10) {
      display_char((int )*str26);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str26 ++;
  }
  goto Lret_display_string___1;
  Lret_display_string___1: 
  display_unsigned(ecrobot_inputs.battery_state / 100UL, (U32___1 )0);
  x14 = 0;
  y15 = 3;
  display_x = x14;
  display_y = y15;
  goto Lret_display_goto_xy___2;
  Lret_display_goto_xy___2: 
  str27 = "REV: ";
  while (*str27) {
    if ((int const   )*str27 != 10) {
      display_char((int )*str27);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str27 ++;
  }
  goto Lret_display_string___2;
  Lret_display_string___2: 
  {
  tmp___0 = nxt_motor_get_count((U32___1 )0);
  val32 = tmp___0;
  places33 = (U32___1 )0;
  {
  if (val32 < 0) {
    tmp34 = - val32;
  } else {
    tmp34 = val32;
  }
  display_unsigned_worker((U32 )tmp34, places33, (U32 )(val32 < 0));
  goto Lret_display_int;
  }
  Lret_display_int:  ;
  tmp___1 = nxt_motor_get_count((U32___1 )1);
  val35 = tmp___1;
  places36 = (U32___1 )6;
  {
  if (val35 < 0) {
    tmp37 = - val35;
  } else {
    tmp37 = val35;
  }
  display_unsigned_worker((U32 )tmp37, places36, (U32 )(val35 < 0));
  goto Lret_display_int___0;
  }
  Lret_display_int___0:  ;
  x16 = 0;
  y17 = 4;
  display_x = x16;
  display_y = y17;
  }
  goto Lret_display_goto_xy___3;
  Lret_display_goto_xy___3: 
  str28 = "     ";
  while (*str28) {
    if ((int const   )*str28 != 10) {
      display_char((int )*str28);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str28 ++;
  }
  goto Lret_display_string___3;
  Lret_display_string___3: 
  {
  tmp___2 = nxt_motor_get_count((U32___1 )2);
  val38 = tmp___2;
  places39 = (U32___1 )0;
  {
  if (val38 < 0) {
    tmp40 = - val38;
  } else {
    tmp40 = val38;
  }
  display_unsigned_worker((U32 )tmp40, places39, (U32 )(val38 < 0));
  goto Lret_display_int___1;
  }
  Lret_display_int___1:  ;
  x18 = 0;
  y19 = 5;
  display_x = x18;
  display_y = y19;
  }
  goto Lret_display_goto_xy___4;
  Lret_display_goto_xy___4: 
  str29 = "ADC1/2:";
  while (*str29) {
    if ((int const   )*str29 != 10) {
      display_char((int )*str29);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str29 ++;
  }
  goto Lret_display_string___4;
  Lret_display_string___4: 
  {
  val41 = (int )adc[0];
  places42 = (U32___1 )0;
  {
  if (val41 < 0) {
    tmp43 = - val41;
  } else {
    tmp43 = val41;
  }
  display_unsigned_worker((U32 )tmp43, places42, (U32 )(val41 < 0));
  goto Lret_display_int___2;
  }
  Lret_display_int___2:  ;
  val44 = (int )adc[1];
  places45 = (U32___1 )5;
  {
  if (val44 < 0) {
    tmp46 = - val44;
  } else {
    tmp46 = val44;
  }
  display_unsigned_worker((U32 )tmp46, places45, (U32 )(val44 < 0));
  goto Lret_display_int___3;
  }
  Lret_display_int___3:  ;
  x20 = 0;
  y21 = 6;
  display_x = x20;
  display_y = y21;
  }
  goto Lret_display_goto_xy___5;
  Lret_display_goto_xy___5: 
  str30 = "ADC3/4:";
  while (*str30) {
    if ((int const   )*str30 != 10) {
      display_char((int )*str30);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str30 ++;
  }
  goto Lret_display_string___5;
  Lret_display_string___5: 
  {
  val47 = (int )adc[2];
  places48 = (U32___1 )0;
  {
  if (val47 < 0) {
    tmp49 = - val47;
  } else {
    tmp49 = val47;
  }
  display_unsigned_worker((U32 )tmp49, places48, (U32 )(val47 < 0));
  goto Lret_display_int___4;
  }
  Lret_display_int___4:  ;
  val50 = (int )adc[3];
  places51 = (U32___1 )5;
  {
  if (val50 < 0) {
    tmp52 = - val50;
  } else {
    tmp52 = val50;
  }
  display_unsigned_worker((U32 )tmp52, places51, (U32 )(val50 < 0));
  goto Lret_display_int___5;
  }
  Lret_display_int___5:  ;
  x22 = 0;
  y23 = 7;
  display_x = x22;
  display_y = y23;
  }
  goto Lret_display_goto_xy___6;
  Lret_display_goto_xy___6: 
  str31 = "BT/DST: ";
  while (*str31) {
    if ((int const   )*str31 != 10) {
      display_char((int )*str31);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str31 ++;
  }
  goto Lret_display_string___6;
  Lret_display_string___6: 
  tmp___3 = ecrobot_get_bt_status();
  if (tmp___3 == 7) {
    display_unsigned((U32___1 )1, (U32___1 )0);
  } else {
    display_unsigned((U32___1 )0, (U32___1 )0);
  }
  {
  tmp___4 = getDistance();
  val53 = (int )tmp___4;
  places54 = (U32___1 )5;
  {
  if (val53 < 0) {
    tmp55 = - val53;
  } else {
    tmp55 = val53;
  }
  display_unsigned_worker((U32 )tmp55, places54, (U32 )(val53 < 0));
  goto Lret_display_int___6;
  }
  Lret_display_int___6: ;
  display_update();
  }
  return;
}
}
void ecrobot_sint_var_monitor(SINT *vars ) 
{ 
  SINT i ;
  int x3 ;
  int y4 ;
  int val5 ;
  U32 places6 ;
  int tmp7 ;
  int val8 ;
  U32 places9 ;
  int tmp10 ;

  {
  display_clear((U32___1 )0);
  i = 0;
  while (i < 8) {
    x3 = 0;
    y4 = i;
    display_x = x3;
    display_y = y4;
    goto Lret_display_goto_xy;
    Lret_display_goto_xy: 
    {
    val5 = *(vars + 2 * i);
    places6 = (U32___1 )8;
    {
    if (val5 < 0) {
      tmp7 = - val5;
    } else {
      tmp7 = val5;
    }
    display_unsigned_worker((U32 )tmp7, places6, (U32 )(val5 < 0));
    goto Lret_display_int;
    }
    Lret_display_int:  ;
    val8 = *(vars + (2 * i + 1));
    places9 = (U32___1 )8;
    {
    if (val8 < 0) {
      tmp10 = - val8;
    } else {
      tmp10 = val8;
    }
    display_unsigned_worker((U32 )tmp10, places9, (U32 )(val8 < 0));
    goto Lret_display_int___0;
    }
    Lret_display_int___0:  ;
    i ++;
    }
  }
  display_update();
  return;
}
}
SINT ecrobot_sound_tone(U32___1 freq , U32___1 ms , U32___1 vol ) 
{ 


  {
  sound_freq_vol(freq, ms, (int )vol);
  return (1);
}
}
SINT ecrobot_sound_wav(CHAR const   *file , U32___1 length , S32___0 freq , U32___1 vol ) 
{ 
  WAV *wav ;
  int tmp ;
  WAV_ND *wav_nd ;
  WAV_FACT *wav_fact ;
  WAV_NL *wav_nl ;

  {
  wav = (WAV *)file;
  tmp = sound_get_time();
  if (tmp > 0) {
    return (0);
  }
  if (length < 44UL) {
    return (-1);
  }
  if (wav->riff.chunkID != 1179011410UL) {
    return (-1);
  }
  if (wav->riff.format != 1163280727UL) {
    return (-1);
  }
  if (wav->fmt.chunkID != 544501094UL) {
    return (-1);
  }
  if ((int )wav->fmt.audioFormat != 1) {
    return (-1);
  }
  if ((int )wav->fmt.numChannels != 1) {
    return (-1);
  }
  if ((int )wav->fmt.bitsPerSample != 8) {
    return (-1);
  }
  if (freq < 0L) {
    freq = (S32___0 )wav->fmt.sampleRate;
  }
  if ((int )wav->fmt.dummy == 0) {
    if (wav->data.chunkID == 1635017060UL) {
      sound_play_sample(wav->data.data, wav->data.chunkSize, (U32___1 )freq, (int )vol);
    } else {
      goto _L___0;
    }
  } else
  _L___0: 
  if ((int )wav->fmt.dummy != 0) {
    wav_nd = (WAV_ND *)file;
    if (wav_nd->data.chunkID == 1635017060UL) {
      sound_play_sample(wav_nd->data.data, wav_nd->data.chunkSize, (U32___1 )freq,
                        (int )vol);
    }
  } else {
    wav_fact = (WAV_FACT *)file;
    if (wav_fact->data.chunkID == 1952670054UL) {
      if (wav_fact->data.data_chunkID == 1635017060UL) {
        sound_play_sample(wav_fact->data.data, wav_fact->data.data_chunkSize, (U32___1 )freq,
                          (int )vol);
      } else {
        goto _L;
      }
    } else {
      _L: 
      wav_nl = (WAV_NL *)file;
      if (wav_nl->data.chunkID == 1635017060UL) {
        sound_play_sample(wav_nl->data.data, wav_nl->data.chunkSize, (U32___1 )freq,
                          (int )vol);
      } else {
        return (-1);
      }
    }
  }
  return (1);
}
}
char const   avr_brainwash_string[48]  = 
  {      (char const   )'\314',      (char const   )'L',      (char const   )'e',      (char const   )'t', 
        (char const   )'\'',      (char const   )'s',      (char const   )' ',      (char const   )'s', 
        (char const   )'a',      (char const   )'m',      (char const   )'b',      (char const   )'a', 
        (char const   )' ',      (char const   )'n',      (char const   )'x',      (char const   )'t', 
        (char const   )' ',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )' ', 
        (char const   )'a',      (char const   )'r',      (char const   )'m',      (char const   )',', 
        (char const   )' ',      (char const   )'(',      (char const   )'c',      (char const   )')', 
        (char const   )'L',      (char const   )'E',      (char const   )'G',      (char const   )'O', 
        (char const   )' ',      (char const   )'S',      (char const   )'y',      (char const   )'s', 
        (char const   )'t',      (char const   )'e',      (char const   )'m',      (char const   )' ', 
        (char const   )'A',      (char const   )'/',      (char const   )'S',      (char const   )'\000'};
*/
static to_avr io_to_avr  ;
static U8___2 data_to_avr[9]  ;
static from_avr data_from_avr[2]  ;
static from_avr *io_from_avr  ;
static U32___2 from_buf  ;
static U16___2 prev_buttons  ;
static U16___2 button_state  ;
static U16___2 debounce_state  ;
static U16___2 debounce_cnt  ;
/*
static void nxt_avr_start_read(void) 
{ 


  {
  twi_start_read((U32___2 )1, (U8___2 *)(& data_from_avr[from_buf]), sizeof(from_avr ));
  return;
}
}
static void nxt_avr_start_send(void) 
{ 
  U32___2 checkByte ;
  U8___2 *a ;
  U8___2 *b ;
  U8___2 *e ;
  U8___2 *tmp ;
  U8___2 *tmp___0 ;

  {
  checkByte = (U32___2 )0;
  a = data_to_avr;
  b = (U8___2 *)(& io_to_avr);
  e = b + sizeof(io_to_avr);
  while ((unsigned long )b < (unsigned long )e) {
    checkByte += (U32___2 )*b;
    tmp = a;
    a ++;
    tmp___0 = b;
    b ++;
    *tmp = *tmp___0;
  }
  *a = (U8___2 )(~ checkByte);
  twi_start_write((U32___2 )1, (U8___2 const   *)(data_to_avr), sizeof(data_to_avr));
  return;
}
}
void nxt_avr_power_down(void) 
{ 


  {
  io_to_avr.power = (U8___2 )90;
  io_to_avr.pwm_frequency = (U8___2 )0;
  return;
}
}
void nxt_avr_firmware_update_mode(void) 
{ 


  {
  io_to_avr.power = (U8___2 )165;
  io_to_avr.pwm_frequency = (U8___2 )90;
  return;
}
}
void nxt_avr_link_init(void) 
{ 
  size_t___0 tmp ;

  {
  tmp = strlen(avr_brainwash_string);
  twi_start_write((U32___2 )1, (U8___2 const   *)(avr_brainwash_string), tmp);
  return;
}
}
static struct __anonstruct_nxt_avr_stats_680423455 nxt_avr_stats  ;
static void nxt_avr_unpack(void) 
{ 
  U8___2 check_sum ;
  U8___2 *p ;
  U8___2 *end ;
  U16___2 buttonsVal ;
  U16___2 newState ;
  U8___2 *tmp ;

  {
  check_sum = (U8___2 )0;
  p = (U8___2 *)(& data_from_avr[from_buf]);
  end = p + sizeof(from_avr );
  while ((unsigned long )p < (unsigned long )end) {
    tmp = p;
    p ++;
    check_sum = (U8___2 )((int )check_sum + (int )*tmp);
  }
  if ((int )check_sum != 255) {
    (nxt_avr_stats.bad_rx) ++;
    return;
  }
  (nxt_avr_stats.good_rx) ++;
  io_from_avr = & data_from_avr[from_buf];
  from_buf = (from_buf + 1UL) & 1UL;
  buttonsVal = io_from_avr->buttonsVal;
  if ((int )buttonsVal > 60) {
    goto _L;
  } else
  if (button_state) {
    _L: 
    if ((int )buttonsVal != (int )prev_buttons) {
      prev_buttons = buttonsVal;
    } else {
      newState = (U16___2 )0;
      if ((int )buttonsVal > 1500) {
        newState = (U16___2 )((int )newState | 1);
        buttonsVal = (U16___2 )((int )buttonsVal - 2047);
      }
      if ((int )buttonsVal > 720) {
        newState = (U16___2 )((int )newState | 8);
      } else
      if ((int )buttonsVal > 270) {
        newState = (U16___2 )((int )newState | 4);
      } else
      if ((int )buttonsVal > 60) {
        newState = (U16___2 )((int )newState | 2);
      }
      if ((int )newState != (int )debounce_state) {
        debounce_cnt = (U16___2 )25;
        debounce_state = newState;
      } else
      if ((int )debounce_cnt > 0) {
        debounce_cnt = (U16___2 )((int )debounce_cnt - 1);
      } else {
        button_state = debounce_state;
      }
    }
  }
  return;
}
}
static U32___2 update_count  ;
static U32___2 link_state  =    (U32___2 )0;
void nxt_avr_init(void) 
{ 


  {
  twi_init();
  memset((void *)(& io_to_avr), 0, sizeof(io_to_avr));
  io_to_avr.power = (U8___2 )0;
  io_to_avr.pwm_frequency = (U8___2 )8;
  button_state = (U16___2 )0;
  prev_buttons = (U16___2 )0;
  debounce_state = (U16___2 )0;
  debounce_cnt = (U16___2 )25;
  link_state = (U32___2 )5;
  from_buf = (U32___2 )0;
  io_from_avr = & data_from_avr[1];
  return;
}
}
void nxt_avr_1kHz_update(void) 
{ 
  int state ;
  U32___2 tmp ;

  {
  switch (link_state) {
  case 0UL: 
  break;
  case 1UL: 
  case 2UL: 
  link_state ++;
  break;
  case 3UL: 
  case 4UL: 
  state = twi_status();
  if (state == 0) {
    tmp = update_count;
    update_count ++;
    if (tmp & 1UL) {
      nxt_avr_start_read();
    } else {
      nxt_avr_start_send();
      nxt_avr_unpack();
    }
    link_state = (U32___2 )3;
  } else
  if (state < 0) {
    (nxt_avr_stats.not_ok) ++;
    link_state = (U32___2 )5;
  } else {
    (nxt_avr_stats.still_busy) ++;
    if (link_state == 3UL) {
      link_state = (U32___2 )4;
    } else {
      link_state = (U32___2 )5;
    }
  }
  break;
  default: 
  twi_init();
  memset((void *)(data_from_avr), 0, sizeof(data_from_avr));
  nxt_avr_link_init();
  update_count = (U32___2 )0;
  (nxt_avr_stats.resets) ++;
  link_state = (U32___2 )1;
  break;
  }
  return;
}
}
unsigned long buttons_get(void) 
{ 


  {
  return ((U32___2 )button_state);
}
}
unsigned long battery_voltage(void) 
{ 
  U32___2 voltageVal ;

  {
  voltageVal = (U32___2 )io_from_avr->extra;
  voltageVal &= 1023UL;
  voltageVal *= 14180UL;
  voltageVal >>= 10;
  return (voltageVal);
}
}
unsigned long sensor_adc(unsigned long n ) 
{ 


  {
  if (n < 4UL) {
    return ((U32___2 )io_from_avr->adc_value[n]);
  } else {
    return ((U32___2 )0);
  }
}
}
void nxt_avr_set_input_power(unsigned long n , unsigned long power_type ) 
{ 
  U8___2 val ;
  int tmp ;

  {
  if (n < 4UL) {
    if (power_type <= 2UL) {
      if (power_type & 2UL) {
        tmp = 16 << n;
      } else {
        tmp = 0;
      }
      val = (U8___2 )((unsigned long )tmp | ((power_type & 1UL) << n));
      io_to_avr.input_power = (U8___2 )((int )io_to_avr.input_power & ~ (17 << n));
      io_to_avr.input_power = (U8___2 )((int )io_to_avr.input_power | (int )val);
    }
  }
  return;
}
}*/
static struct motor_struct motor[3]  ;
static U32___3 nxt_motor_initialised  ;
static U32___3 interrupts_this_period  ;
/*int nxt_motor_get_count(unsigned long n ) 
{ 


  {
  if (n < 3UL) {
    return (motor[n].current_count);
  } else {
    return (0);
  }
}
}
void nxt_motor_set_count(unsigned long n , int count ) 
{ 


  {
  if (n < 3UL) {
    motor[n].current_count = count;
  }
  return;
}
}
void nxt_motor_command(unsigned long n , int cmd , int target_count , int speed_percent ) 
{ 


  {
  if (n < 3UL) {
    motor[n].target_count = target_count;
    motor[n].speed_percent = speed_percent;
  }
  return;
}
}
void nxt_motor_1kHz_process(void) 
{ 


  {
  if (nxt_motor_initialised) {
    interrupts_this_period = (U32___3 )0;
    *((AT91_REG___1 *)4294964288U) = (AT91_REG___1 )(((1 << 15) | (1 << 26)) | 1);
  }
  return;
}
}
void nxt_motor_quad_decode(struct motor_struct *m , U32___3 value ) 
{ 
  U32___3 dir ;
  U32___3 edge ;

  {
  dir = value & 2UL;
  edge = value & 1UL;
  if (edge != m->last) {
    if (edge) {
      if (! dir) {
        (m->current_count) ++;
      } else {
        goto _L___1;
      }
    } else
    _L___1: 
    if (edge) {
      if (dir) {
        (m->current_count) --;
      } else {
        goto _L___0;
      }
    } else
    _L___0: 
    if (! edge) {
      if (dir) {
        (m->current_count) ++;
      } else {
        goto _L;
      }
    } else
    _L: 
    if (! edge) {
      if (! dir) {
        (m->current_count) --;
      }
    }
    m->last = edge;
  }
  return;
}
}*/
extern void nxt_motor_isr_entry(void) ;
/*void nxt_motor_isr_C(void) 
{ 
  U32___3 i_state ;
  int tmp ;
  U32___3 pinChanges ;
  U32___3 currentPins ;
  U32___3 pins ;

  {
  tmp = interrupts_get_and_disable();
  i_state = (U32___3 )tmp;
  pinChanges = (U32___3 )*((AT91_REG___1 *)4294964300U);
  currentPins = (U32___3 )*((AT91_REG___1 *)4294964284U);
  interrupts_this_period ++;
  if (interrupts_this_period > 4UL) {
    *((AT91_REG___1 *)4294964292U) = (AT91_REG___1 )(((1 << 15) | (1 << 26)) | 1);
  }
  pins = ((currentPins >> 15) & 1UL) | (currentPins & 2UL);
  nxt_motor_quad_decode(& motor[0], pins);
  pins = ((currentPins >> 26) & 1UL) | ((currentPins >> 8) & 2UL);
  nxt_motor_quad_decode(& motor[1], pins);
  pins = (currentPins & 1UL) | ((currentPins >> 7) & 2UL);
  nxt_motor_quad_decode(& motor[2], pins);
  if (i_state) {
    interrupts_enable();
  }
  return;
}
}
void nxt_motor_init(void) 
{ 


  {
  *((AT91_REG___1 *)4294966288U) = (AT91_REG___1 )(1 << 2);
  *((AT91_REG___1 *)4294964292U) = (AT91_REG___1 )(~ 0);
  *((AT91_REG___1 *)4294964256U) = (AT91_REG___1 )((((((1 << 15) | (1 << 1)) | (1 << 26)) | (1 << 9)) | 1) | (1 << 8));
  *((AT91_REG___1 *)4294964320U) = (AT91_REG___1 )((((((1 << 15) | (1 << 1)) | (1 << 26)) | (1 << 9)) | 1) | (1 << 8));
  *((AT91_REG___1 *)4294964224U) = (AT91_REG___1 )((((((1 << 15) | (1 << 1)) | (1 << 26)) | (1 << 9)) | 1) | (1 << 8));
  *((AT91_REG___1 *)4294964244U) = (AT91_REG___1 )((((((1 << 15) | (1 << 1)) | (1 << 26)) | (1 << 9)) | 1) | (1 << 8));
  aic_mask_off((U32___3 )2);
  aic_set_vector((U32___3 )2, (U32___3 )4, (U32___3 )(& nxt_motor_isr_entry));
  aic_mask_on((U32___3 )2);
  *((AT91_REG___1 *)4294964288U) = (AT91_REG___1 )(((1 << 15) | (1 << 26)) | 1);
  nxt_motor_initialised = (U32___3 )1;
  return;
}
}*/
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
extern StatusType TerminateTask(void) ;
extern StatusType GetResource(ResourceType resid ) ;
extern StatusType ReleaseResource(ResourceType resid ) ;
extern ResourceType DrivingControlResource ;
struct dc_t dc  =    {(U32___4 )0, (S32___1 )0, (S32___1 )0, 5};
U32___4 SeekStarted  ;
S32___1 LastSonarValue  ;
int InSetupPhase  ;
U32___4 SetupStarted  ;
void TaskMainMotorcontrolTask(void) 
{ 
  U32___3 n1 ;
  int speed_percent2 ;
  int brake3 ;
  U32___3 n4 ;
  int speed_percent5 ;
  int brake6 ;
  U32___2 n7 ;
  int power_percent8 ;
  int brake9 ;
  U32___2 n10 ;
  int power_percent11 ;
  int brake12 ;

  {
  if (InSetupPhase) {
    TerminateTask();
  }
  GetResource(DrivingControlResource);
  if (dc.duration > 0UL) {
    dc.duration -= 50UL;
  } else {
    dc.priority = 5;
    dc.duration = (U32___4 )0;
    dc.speed_left = (S32___1 )0;
    dc.speed_right = (S32___1 )0;
  }
  n1 = (U32___4 )1;
  speed_percent2 = (int )(- dc.speed_left);
  brake3 = 1;
  if (n1 < 3UL) {
    if (speed_percent2 > 100) {
      speed_percent2 = 100;
    }
    if (speed_percent2 < -100) {
      speed_percent2 = -100;
    }
    motor[n1].speed_percent = speed_percent2;
    n7 = n1;
    power_percent8 = speed_percent2;
    brake9 = brake3;
    if (n7 < 3UL) {
      io_to_avr.output_percent[n7] = (S8___1 )power_percent8;
      if (brake9) {
        io_to_avr.output_mode = (U8___2 )((int )io_to_avr.output_mode | (1 << n7));
      } else {
        io_to_avr.output_mode = (U8___2 )((int )io_to_avr.output_mode & ~ (1 << n7));
      }
    }
    goto Lret_nxt_avr_set_motor;
    Lret_nxt_avr_set_motor: ;
  }
  goto Lret_nxt_motor_set_speed;
  Lret_nxt_motor_set_speed: 
  n4 = (U32___4 )0;
  speed_percent5 = (int )(- dc.speed_right);
  brake6 = 1;
  if (n4 < 3UL) {
    if (speed_percent5 > 100) {
      speed_percent5 = 100;
    }
    if (speed_percent5 < -100) {
      speed_percent5 = -100;
    }
    motor[n4].speed_percent = speed_percent5;
    n10 = n4;
    power_percent11 = speed_percent5;
    brake12 = brake6;
    if (n10 < 3UL) {
      io_to_avr.output_percent[n10] = (S8___1 )power_percent11;
      if (brake12) {
        io_to_avr.output_mode = (U8___2 )((int )io_to_avr.output_mode | (1 << n10));
      } else {
        io_to_avr.output_mode = (U8___2 )((int )io_to_avr.output_mode & ~ (1 << n10));
      }
    }
    goto Lret_nxt_avr_set_motor___0;
    Lret_nxt_avr_set_motor___0: ;
  }
  goto Lret_nxt_motor_set_speed___0;
  Lret_nxt_motor_set_speed___0: 
  ReleaseResource(DrivingControlResource);
  TerminateTask();
  return;
}
}
void TaskMainColorSensorTask(void) 
{ 
  U16___3 color ;
  U16___3 tmp ;
  int priority3 ;
  int speed_left4 ;
  int speed_right5 ;
  int duration6 ;
  U8___1 port_id7 ;
  unsigned short ret_ecrobot_get_nxtcolorsensor_light8 ;
  int port_id9 ;
  NXTCOLORSENSOR_T *sd10 ;
  U8___1 mode11 ;
  int tmp12 ;
  int tmp___013 ;

  {
  if (InSetupPhase) {
    TerminateTask();
  }
  port_id9 = 0;
  while (port_id9 < 4) {
    sd10 = & sensor_data[port_id9];
    if (sd10->port_in_use) {
      mode11 = (U8___1 )sd10->mode;
      if ((int )mode11 == 6) {
        sd10->port_in_use = (U8___1 volatile   )0;
        colorsensor_init(port_id9, (unsigned char)136);
        goto Lret_ecrobot_process_bg_nxtcolorsensor;
      } else
      if ((int )mode11 != (int )sd10->mode_state) {
        sd10->color = (U16___1 )99;
        sd10->rgb[0] = (S16___0 )0;
        sd10->rgb[1] = (S16___0 )0;
        sd10->rgb[2] = (S16___0 )0;
        sd10->light = (U16___1 )0;
        sd10->mode_state = (U8___1 volatile   )mode11;
        colorsensor_init(port_id9, (unsigned char)136);
        colorsensor_init(port_id9, (unsigned char )NXT_COLORSENSOR_PROTOCOLS[mode11]);
      }
      if ((int )mode11 == 0) {
        tmp12 = colorsensor_color_get(port_id9);
        sd10->color = (U16___1 )tmp12;
        colorsensor_rgb_get(port_id9, sd10->rgb);
      } else {
        tmp___013 = colorsensor_light_get(port_id9);
        sd10->light = (U16___1 )tmp___013;
        if ((int )mode11 == 4) {
          colorsensor_light_full(port_id9);
        }
      }
    }
    port_id9 ++;
  }
  goto Lret_ecrobot_process_bg_nxtcolorsensor;
  Lret_ecrobot_process_bg_nxtcolorsensor: 
  port_id7 = (U8___3 )0;
  ret_ecrobot_get_nxtcolorsensor_light8 = sensor_data[port_id7].light;
  goto Lret_ecrobot_get_nxtcolorsensor_light;
  Lret_ecrobot_get_nxtcolorsensor_light: 
  tmp = ret_ecrobot_get_nxtcolorsensor_light8;
  color = tmp;
  if ((int )color < 300) {
    GetResource(DrivingControlResource);
    priority3 = 50;
    speed_left4 = -100;
    speed_right5 = -100;
    duration6 = 1250;
    GetResource(DrivingControlResource);
    if (dc.priority != 20) {
      SeekStarted = (U32___4 )0;
    }
    if (priority3 >= dc.priority) {
      dc.priority = priority3;
      dc.speed_left = (S32___1 )speed_left4;
      dc.speed_right = (S32___1 )speed_right5;
      dc.duration = (U32___4 )duration6;
    }
    ReleaseResource(DrivingControlResource);
    goto Lret_change_driving_command;
    Lret_change_driving_command: 
    ReleaseResource(DrivingControlResource);
  }
  TerminateTask();
  return;
}
}
extern int copysign() ;
void TaskMainSonarSensorTask(void) 
{ 
  int duration ;
  S32___1 distance ;
  S32___1 tmp ;
  int seek_delay_1 ;
  int seek_delay_2 ;
  int seek_delay_3 ;
  int seek_delay_4 ;
  int speed_left ;
  int speed_right ;
  int modifier ;
  int tmp___0 ;
  int tmp___1 ;
  U32___4 current_sys_tick ;
  U32___4 tmp___2 ;
  U32___4 delta ;
  int priority16 ;
  int speed_left17 ;
  int speed_right18 ;
  int duration19 ;
  int priority20 ;
  int speed_left21 ;
  int speed_right22 ;
  int duration23 ;
  int priority24 ;
  int speed_left25 ;
  int speed_right26 ;
  int duration27 ;
  int priority28 ;
  int speed_left29 ;
  int speed_right30 ;
  int duration31 ;
  int priority32 ;
  int speed_left33 ;
  int speed_right34 ;
  int duration35 ;
  int priority36 ;
  int speed_left37 ;
  int speed_right38 ;
  int duration39 ;
  U8___1 port_id40 ;
  int tmp41 ;
  long ret_ecrobot_get_sonar_sensor42 ;
  int port43 ;
  U32___0 address44 ;
  int internal_address45 ;
  int n_internal_address_bytes46 ;
  U8___0 *data47 ;
  U32___0 nbytes48 ;
  int write49 ;
  struct i2c_port_struct *p50 ;
  struct i2c_partial_transaction *pt51 ;
  int tmp52 ;
  int tmp___053 ;

  {
  if (InSetupPhase) {
    TerminateTask();
  }
  duration = 3000;
  port_id40 = (U8___3 )1;
  tmp41 = i2c_busy((int )port_id40);
  if (tmp41 == 0) {
   // distance_state[port_id40] = (S32___0 )data[port_id40];
    port43 = (int )port_id40;
    address44 = (U32___1 )1;
    internal_address45 = 66;
    n_internal_address_bytes46 = 1;
   // data47 = & data[port_id40];
    nbytes48 = (U32___1 )1;
    write49 = 0;
    if (port43 < 0) {
      goto Lret_i2c_start_transaction;
    } else
    if (port43 >= 4) {
      goto Lret_i2c_start_transaction;
    }
    tmp52 = i2c_busy(port43);
    if (tmp52) {
      goto Lret_i2c_start_transaction;
    }
    p50 = & i2c_port[port43];
    p50->pt_num = (U32___0 )0;
    p50->pt_begun = (U32___0 )0;
    pt51 = p50->partial_transaction;
    p50->current_pt = pt51;
    memset((void *)pt51, 0, sizeof(p50->partial_transaction));
    if (n_internal_address_bytes46 > 0) {
      p50->addr_int[0] = (U8___0 )(address44 << 1);
      p50->addr_int[1] = (U8___0 )internal_address45;
      pt51->start = (U8___0 )1;
      if (write49) {
        pt51->stop = (U8___0 )0;
      } else {
        pt51->stop = (U8___0 )1;
      }
      pt51->tx = (U8___0 )1;
      pt51->data = p50->addr_int;
      pt51->nbytes = (U16___0 )2;
      pt51 ++;
    }
    if (n_internal_address_bytes46 == 0) {
      goto _L___2;
    } else
    if (! write49) {
      _L___2: 
      if (n_internal_address_bytes46 > 0) {
        pt51->start = (U8___0 )0;
      } else {
        pt51->start = (U8___0 )1;
      }
      pt51->restart = (U8___0 )(! pt51->start);
      pt51->stop = (U8___0 )0;
      pt51->tx = (U8___0 )1;
      if (write49) {
        tmp___053 = 0;
      } else {
        tmp___053 = 1;
      }
      p50->addr = (U8___0 )((address44 << 1) | (unsigned long )tmp___053);
      pt51->data = & p50->addr;
      pt51->nbytes = (U16___0 )1;
      pt51 ++;
    }
    pt51->start = (U8___0 )0;
    pt51->stop = (U8___0 )1;
    if (write49) {
      pt51->tx = (U8___0 )1;
    } else {
      pt51->tx = (U8___0 )0;
    }
    pt51->data = data47;
    pt51->nbytes = (U16___0 )nbytes48;
    pt51->last_pt = (U8___0 )1;
    p50->state = (i2c_port_state )2;
    goto Lret_i2c_start_transaction;
    Lret_i2c_start_transaction: ;
  }
  ret_ecrobot_get_sonar_sensor42 = distance_state[port_id40];
  goto Lret_ecrobot_get_sonar_sensor;
  Lret_ecrobot_get_sonar_sensor: 
  tmp = ret_ecrobot_get_sonar_sensor42;
  distance = tmp;
  if (LastSonarValue == 0L) {
    LastSonarValue = (S32___1 )255;
  }
  if (distance == 255L) {
    if (LastSonarValue < 20L) {
      priority16 = 30;
      speed_left17 = 100;
      speed_right18 = 100;
      duration19 = 150;
      GetResource(DrivingControlResource);
      if (dc.priority != 20) {
        SeekStarted = (U32___4 )0;
      }
      if (priority16 >= dc.priority) {
        dc.priority = priority16;
        dc.speed_left = (S32___1 )speed_left17;
        dc.speed_right = (S32___1 )speed_right18;
        dc.duration = (U32___4 )duration19;
      }
      ReleaseResource(DrivingControlResource);
      goto Lret_change_driving_command;
      Lret_change_driving_command: ;
    } else {
      LastSonarValue = distance;
    }
  } else {
    LastSonarValue = distance;
  }
  seek_delay_1 = 1000;
  seek_delay_2 = seek_delay_1 * 2;
  seek_delay_3 = seek_delay_2 * 2;
  seek_delay_4 = seek_delay_3 + 2000;
  if (distance > 70L) {
    if (SeekStarted == 0UL) {
      SeekStarted = systick_get_ms();
      tmp___0 = rand();
      tmp___1 = copysign(1, tmp___0 - 1073741823);
      modifier = tmp___1;
      speed_left = -70 * modifier;
      speed_right = 70 * modifier;
      priority20 = 20;
      speed_left21 = speed_left;
      speed_right22 = speed_right;
      duration23 = duration;
      GetResource(DrivingControlResource);
      if (dc.priority != 20) {
        SeekStarted = (U32___4 )0;
      }
      if (priority20 >= dc.priority) {
        dc.priority = priority20;
        dc.speed_left = (S32___1 )speed_left21;
        dc.speed_right = (S32___1 )speed_right22;
        dc.duration = (U32___4 )duration23;
      }
      ReleaseResource(DrivingControlResource);
      goto Lret_change_driving_command___0;
      Lret_change_driving_command___0: ;
    } else {
      tmp___2 = systick_get_ms();
      current_sys_tick = tmp___2;
      delta = current_sys_tick - SeekStarted;
      if (delta > (U32___4 )seek_delay_1) {
        if (delta <= (U32___4 )(seek_delay_1 + 100)) {
          GetResource(DrivingControlResource);
          speed_left = (int )(dc.speed_left * -1L);
          speed_right = (int )(dc.speed_right * -1L);
          ReleaseResource(DrivingControlResource);
          priority24 = 20;
          speed_left25 = speed_left;
          speed_right26 = speed_right;
          duration27 = duration;
          GetResource(DrivingControlResource);
          if (dc.priority != 20) {
            SeekStarted = (U32___4 )0;
          }
          if (priority24 >= dc.priority) {
            dc.priority = priority24;
            dc.speed_left = (S32___1 )speed_left25;
            dc.speed_right = (S32___1 )speed_right26;
            dc.duration = (U32___4 )duration27;
          }
          ReleaseResource(DrivingControlResource);
          goto Lret_change_driving_command___1;
          Lret_change_driving_command___1: ;
        } else {
          goto _L___1;
        }
      } else
      _L___1: 
      if (delta > (U32___4 )seek_delay_2) {
        if (delta <= (U32___4 )(seek_delay_2 + 100)) {
          GetResource(DrivingControlResource);
          speed_left = (int )(dc.speed_left * -1L);
          speed_right = (int )(dc.speed_right * -1L);
          ReleaseResource(DrivingControlResource);
          priority28 = 20;
          speed_left29 = speed_left;
          speed_right30 = speed_right;
          duration31 = duration;
          GetResource(DrivingControlResource);
          if (dc.priority != 20) {
            SeekStarted = (U32___4 )0;
          }
          if (priority28 >= dc.priority) {
            dc.priority = priority28;
            dc.speed_left = (S32___1 )speed_left29;
            dc.speed_right = (S32___1 )speed_right30;
            dc.duration = (U32___4 )duration31;
          }
          ReleaseResource(DrivingControlResource);
          goto Lret_change_driving_command___2;
          Lret_change_driving_command___2: ;
        } else {
          goto _L___0;
        }
      } else
      _L___0: 
      if (delta > (U32___4 )seek_delay_3) {
        if (delta <= (U32___4 )seek_delay_4) {
          speed_left = 100;
          speed_right = 100;
          priority32 = 20;
          speed_left33 = speed_left;
          speed_right34 = speed_right;
          duration35 = duration;
          GetResource(DrivingControlResource);
          if (dc.priority != 20) {
            SeekStarted = (U32___4 )0;
          }
          if (priority32 >= dc.priority) {
            dc.priority = priority32;
            dc.speed_left = (S32___1 )speed_left33;
            dc.speed_right = (S32___1 )speed_right34;
            dc.duration = (U32___4 )duration35;
          }
          ReleaseResource(DrivingControlResource);
          goto Lret_change_driving_command___3;
          Lret_change_driving_command___3: ;
        } else {
          goto _L;
        }
      } else
      _L: 
      if (delta > (U32___4 )seek_delay_4) {
        SeekStarted = (U32___4 )0;
      }
    }
  } else {
    priority36 = 30;
    speed_left37 = 100;
    speed_right38 = 100;
    duration39 = 150;
    GetResource(DrivingControlResource);
    if (dc.priority != 20) {
      SeekStarted = (U32___4 )0;
    }
    if (priority36 >= dc.priority) {
      dc.priority = priority36;
      dc.speed_left = (S32___1 )speed_left37;
      dc.speed_right = (S32___1 )speed_right38;
      dc.duration = (U32___4 )duration39;
    }
    ReleaseResource(DrivingControlResource);
    goto Lret_change_driving_command___4;
    Lret_change_driving_command___4: ;
  }
  TerminateTask();
  return;
}
}
void TaskMainDisplayTask(void) 
{ 
  U32___4 tmp ;
  U16___3 color ;
  U16___3 tmp___0 ;
  S32___1 sonar ;
  S32___1 tmp___1 ;
  U8___1 port_id6 ;
  int tmp7 ;
  long ret_ecrobot_get_sonar_sensor8 ;
  U8___1 port_id9 ;
  unsigned short ret_ecrobot_get_nxtcolorsensor_light10 ;
  int port11 ;
  U32___0 address12 ;
  int internal_address13 ;
  int n_internal_address_bytes14 ;
  U8___0 *data15 ;
  U32___0 nbytes16 ;
  int write17 ;
  struct i2c_port_struct *p18 ;
  struct i2c_partial_transaction *pt19 ;
  int tmp20 ;
  int tmp___021 ;
  int x22 ;
  int y23 ;
  int x24 ;
  int y25 ;
  int x26 ;
  int y27 ;
  int x28 ;
  int y29 ;
  int x30 ;
  int y31 ;
  int x32 ;
  int y33 ;
  int x34 ;
  int y35 ;
  char const   *str36 ;
  char const   *str37 ;
  char const   *str38 ;
  char const   *str39 ;
  char const   *str40 ;
  char const   *str41 ;
  char const   *str42 ;
  char const   *str43 ;
  char const   *str44 ;
  char const   *str45 ;
  char const   *str46 ;
  char const   *str47 ;
  char const   *str48 ;
  int val49 ;
  U32 places50 ;
  int tmp51 ;
  int val52 ;
  U32 places53 ;
  int tmp54 ;
  int val55 ;
  U32 places56 ;
  int tmp57 ;
  int val58 ;
  U32 places59 ;
  int tmp60 ;
  int val61 ;
  U32 places62 ;
  int tmp63 ;
  int val64 ;
  U32 places65 ;
  int tmp66 ;
  int val67 ;
  U32 places68 ;
  int tmp69 ;
  int val70 ;
  U32 places71 ;
  int tmp72 ;

  {
  if (InSetupPhase) {
    TerminateTask();
  }
  display_clear((U32___4 )0);
  GetResource(DrivingControlResource);
  x22 = 0;
  y23 = 0;
  display_x = x22;
  display_y = y23;
  goto Lret_display_goto_xy;
  Lret_display_goto_xy: 
  str36 = "PRIO: ";
  while (*str36) {
    if ((int const   )*str36 != 10) {
      display_char((int )*str36);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str36 ++;
  }
  goto Lret_display_string;
  Lret_display_string: ;
  switch (dc.priority) {
  case 5: 
  str37 = "IDLE";
  while (*str37) {
    if ((int const   )*str37 != 10) {
      display_char((int )*str37);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str37 ++;
  }
  goto Lret_display_string___0;
  Lret_display_string___0: ;
  break;
  case 20: 
  str38 = "SEEK";
  while (*str38) {
    if ((int const   )*str38 != 10) {
      display_char((int )*str38);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str38 ++;
  }
  goto Lret_display_string___1;
  Lret_display_string___1: ;
  break;
  case 30: 
  str39 = "FOLLOW";
  while (*str39) {
    if ((int const   )*str39 != 10) {
      display_char((int )*str39);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str39 ++;
  }
  goto Lret_display_string___2;
  Lret_display_string___2: ;
  break;
  case 50: 
  str40 = "COLOR";
  while (*str40) {
    if ((int const   )*str40 != 10) {
      display_char((int )*str40);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str40 ++;
  }
  goto Lret_display_string___3;
  Lret_display_string___3: ;
  break;
  default: 
  str41 = "WTF: ";
  while (*str41) {
    if ((int const   )*str41 != 10) {
      display_char((int )*str41);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str41 ++;
  }
  goto Lret_display_string___4;
  Lret_display_string___4: 
  {
  val49 = dc.priority;
  places50 = (U32___4 )3;
  {
  if (val49 < 0) {
    tmp51 = - val49;
  } else {
    tmp51 = val49;
  }
  display_unsigned_worker((U32 )tmp51, places50, (U32 )(val49 < 0));
  goto Lret_display_int;
  }
  Lret_display_int:  ;
  }
  break;
  }
  x24 = 0;
  y25 = 1;
  display_x = x24;
  display_y = y25;
  goto Lret_display_goto_xy___0;
  Lret_display_goto_xy___0: 
  str42 = "SPEED L/R: ";
  while (*str42) {
    if ((int const   )*str42 != 10) {
      display_char((int )*str42);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str42 ++;
  }
  goto Lret_display_string___5;
  Lret_display_string___5: 
  x26 = 0;
  y27 = 2;
  display_x = x26;
  display_y = y27;
  goto Lret_display_goto_xy___1;
  Lret_display_goto_xy___1: 
  {
  val52 = (int )dc.speed_left;
  places53 = (U32___4 )4;
  {
  if (val52 < 0) {
    tmp54 = - val52;
  } else {
    tmp54 = val52;
  }
  display_unsigned_worker((U32 )tmp54, places53, (U32 )(val52 < 0));
  goto Lret_display_int___0;
  }
  Lret_display_int___0:  ;
  str43 = "/";
  }
  while (*str43) {
    if ((int const   )*str43 != 10) {
      display_char((int )*str43);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str43 ++;
  }
  goto Lret_display_string___6;
  Lret_display_string___6: 
  {
  val55 = (int )dc.speed_right;
  places56 = (U32___4 )4;
  {
  if (val55 < 0) {
    tmp57 = - val55;
  } else {
    tmp57 = val55;
  }
  display_unsigned_worker((U32 )tmp57, places56, (U32 )(val55 < 0));
  goto Lret_display_int___1;
  }
  Lret_display_int___1:  ;
  x28 = 0;
  y29 = 3;
  display_x = x28;
  display_y = y29;
  }
  goto Lret_display_goto_xy___2;
  Lret_display_goto_xy___2: 
  str44 = "DURATION: ";
  while (*str44) {
    if ((int const   )*str44 != 10) {
      display_char((int )*str44);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str44 ++;
  }
  goto Lret_display_string___7;
  Lret_display_string___7: 
  {
  val58 = (int )dc.duration;
  places59 = (U32___4 )0;
  {
  if (val58 < 0) {
    tmp60 = - val58;
  } else {
    tmp60 = val58;
  }
  display_unsigned_worker((U32 )tmp60, places59, (U32 )(val58 < 0));
  goto Lret_display_int___2;
  }
  Lret_display_int___2:  ;
  ReleaseResource(DrivingControlResource);
  x30 = 0;
  y31 = 4;
  display_x = x30;
  display_y = y31;
  }
  goto Lret_display_goto_xy___3;
  Lret_display_goto_xy___3: 
  str45 = "SYSTEM: ";
  while (*str45) {
    if ((int const   )*str45 != 10) {
      display_char((int )*str45);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str45 ++;
  }
  goto Lret_display_string___8;
  Lret_display_string___8: 
  {
  tmp = systick_get_ms();
  val61 = (int )tmp;
  places62 = (U32___4 )0;
  {
  if (val61 < 0) {
    tmp63 = - val61;
  } else {
    tmp63 = val61;
  }
  display_unsigned_worker((U32 )tmp63, places62, (U32 )(val61 < 0));
  goto Lret_display_int___3;
  }
  Lret_display_int___3:  ;
  port_id9 = (U8___3 )0;
  ret_ecrobot_get_nxtcolorsensor_light10 = sensor_data[port_id9].light;
  }
  goto Lret_ecrobot_get_nxtcolorsensor_light;
  Lret_ecrobot_get_nxtcolorsensor_light: 
  tmp___0 = ret_ecrobot_get_nxtcolorsensor_light10;
  color = tmp___0;
  x32 = 0;
  y33 = 5;
  display_x = x32;
  display_y = y33;
  goto Lret_display_goto_xy___4;
  Lret_display_goto_xy___4: 
  str46 = "COLOR: ";
  while (*str46) {
    if ((int const   )*str46 != 10) {
      display_char((int )*str46);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str46 ++;
  }
  goto Lret_display_string___9;
  Lret_display_string___9: 
  {
  val64 = (int )color;
  places65 = (U32___4 )0;
  {
  if (val64 < 0) {
    tmp66 = - val64;
  } else {
    tmp66 = val64;
  }
  display_unsigned_worker((U32 )tmp66, places65, (U32 )(val64 < 0));
  goto Lret_display_int___4;
  }
  Lret_display_int___4:  ;
  port_id6 = (U8___3 )1;
  tmp7 = i2c_busy((int )port_id6);
  }
  if (tmp7 == 0) {
   // distance_state[port_id6] = (S32___0 )data[port_id6];
    port11 = (int )port_id6;
    address12 = (U32___1 )1;
    internal_address13 = 66;
    n_internal_address_bytes14 = 1;
    //data15 = & data[port_id6];
    nbytes16 = (U32___1 )1;
    write17 = 0;
    if (port11 < 0) {
      goto Lret_i2c_start_transaction;
    } else
    if (port11 >= 4) {
      goto Lret_i2c_start_transaction;
    }
    tmp20 = i2c_busy(port11);
    if (tmp20) {
      goto Lret_i2c_start_transaction;
    }
    p18 = & i2c_port[port11];
    p18->pt_num = (U32___0 )0;
    p18->pt_begun = (U32___0 )0;
    pt19 = p18->partial_transaction;
    p18->current_pt = pt19;
    memset((void *)pt19, 0, sizeof(p18->partial_transaction));
    if (n_internal_address_bytes14 > 0) {
      p18->addr_int[0] = (U8___0 )(address12 << 1);
      p18->addr_int[1] = (U8___0 )internal_address13;
      pt19->start = (U8___0 )1;
      if (write17) {
        pt19->stop = (U8___0 )0;
      } else {
        pt19->stop = (U8___0 )1;
      }
      pt19->tx = (U8___0 )1;
      pt19->data = p18->addr_int;
      pt19->nbytes = (U16___0 )2;
      pt19 ++;
    }
    if (n_internal_address_bytes14 == 0) {
      goto _L;
    } else
    if (! write17) {
      _L: 
      if (n_internal_address_bytes14 > 0) {
        pt19->start = (U8___0 )0;
      } else {
        pt19->start = (U8___0 )1;
      }
      pt19->restart = (U8___0 )(! pt19->start);
      pt19->stop = (U8___0 )0;
      pt19->tx = (U8___0 )1;
      if (write17) {
        tmp___021 = 0;
      } else {
        tmp___021 = 1;
      }
      p18->addr = (U8___0 )((address12 << 1) | (unsigned long )tmp___021);
      pt19->data = & p18->addr;
      pt19->nbytes = (U16___0 )1;
      pt19 ++;
    }
    pt19->start = (U8___0 )0;
    pt19->stop = (U8___0 )1;
    if (write17) {
      pt19->tx = (U8___0 )1;
    } else {
      pt19->tx = (U8___0 )0;
    }
    pt19->data = data15;
    pt19->nbytes = (U16___0 )nbytes16;
    pt19->last_pt = (U8___0 )1;
    p18->state = (i2c_port_state )2;
    goto Lret_i2c_start_transaction;
    Lret_i2c_start_transaction: ;
  }
  ret_ecrobot_get_sonar_sensor8 = distance_state[port_id6];
  goto Lret_ecrobot_get_sonar_sensor;
  Lret_ecrobot_get_sonar_sensor: 
  tmp___1 = ret_ecrobot_get_sonar_sensor8;
  sonar = tmp___1;
  x34 = 0;
  y35 = 6;
  display_x = x34;
  display_y = y35;
  goto Lret_display_goto_xy___5;
  Lret_display_goto_xy___5: 
  str47 = "SONAR: ";
  while (*str47) {
    if ((int const   )*str47 != 10) {
      display_char((int )*str47);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str47 ++;
  }
  goto Lret_display_string___10;
  Lret_display_string___10: 
  {
  val67 = (int )sonar;
  places68 = (U32___4 )0;
  {
  if (val67 < 0) {
    tmp69 = - val67;
  } else {
    tmp69 = val67;
  }
  display_unsigned_worker((U32 )tmp69, places68, (U32 )(val67 < 0));
  goto Lret_display_int___5;
  }
  Lret_display_int___5:  ;
  str48 = " / ";
  }
  while (*str48) {
    if ((int const   )*str48 != 10) {
      display_char((int )*str48);
      display_x ++;
    } else {
      display_x = 0;
      display_y ++;
    }
    str48 ++;
  }
  goto Lret_display_string___11;
  Lret_display_string___11: 
  {
  val70 = (int )LastSonarValue;
  places71 = (U32___4 )0;
  {
  if (val70 < 0) {
    tmp72 = - val70;
  } else {
    tmp72 = val70;
  }
  display_unsigned_worker((U32 )tmp72, places71, (U32 )(val70 < 0));
  goto Lret_display_int___6;
  }
  Lret_display_int___6:  ;
  display_update();
  TerminateTask();
  }
  return;
}
}
extern int create_block() ;
extern int create_task() ;
void main(void) 
{ 

  { 
  create_task("TaskMainDisplayTask", "TaskMainDisplayTask", 10, 250, 0.411);
  create_task("TaskMainColorSensorTask", "TaskMainColorSensorTask", 2, 100, 0.068);
  create_task("TaskMainSonarSensorTask", "TaskMainSonarSensorTask", 5, 100, 0.114);
  create_task("TaskMainMotorControlTask", "TaskMainMotorControlTask", 1, 50, 0.074);
  create_block(4280, "TaskMainMotorControlTask", "DrivingControlResource", 1, 1, 0.071);
  create_block(4411, "TaskMainColorSensorTask", "DrivingControlResource", 2, 2, 0.028);
  create_block(4416, "TaskMainColorSensorTask", "DrivingControlResource", 2, 2, 0.02);
  create_block(4830, "TaskMainDisplayTask", "DrivingControlResource", 1, 10, 0.22);
  create_block(4589, "TaskMainSonarSensorTask", "DrivingControlResource", 8, 5, 0.019);
  create_block(4624, "TaskMainSonarSensorTask", "DrivingControlResource", 8, 5, 0.018);
  create_block(4643, "TaskMainSonarSensorTask", "DrivingControlResource", 8, 5, 0.01);
  create_block(4651, "TaskMainSonarSensorTask", "DrivingControlResource", 8, 5, 0.018);
  create_block(4671, "TaskMainSonarSensorTask", "DrivingControlResource", 8, 5, 0.012);
  create_block(4679, "TaskMainSonarSensorTask", "DrivingControlResource", 8, 5, 0.019);
  create_block(4705, "TaskMainSonarSensorTask", "DrivingControlResource", 8, 5, 0.022);
  create_block(4732, "TaskMainSonarSensorTask", "DrivingControlResource", 8, 5, 0.019);
  return;
}
}

